import os
import re
import site
from asyncio import CancelledError

from aiohttp import web, ClientConnectorError
from aiohttp.web_exceptions import HTTPClientError
from aiohttp.web_request import Request
from aiohttp_apispec import setup_aiohttp_apispec, validation_middleware
from hr_prometheus import hrprometheus_middleware
from hr_prometheus.monitors import RequestMonitor
from prometheus_client.metrics import Gauge

import versioneer
from compel_shared import __version__ as shared_version, write_file_safe, remove_file_safe
from compel_shared.access_logger import StructAccessLogger
from compel_shared.config import API_PATH, HOME_PATH, DOCS_PATH, env, PROMETHEUS_MULTIPROC_PATH, CLIENT_MAX_SIZE
from compel_shared.logger import get_logger, add_request_id_middleware

log = get_logger(__name__)


class HTTPError499(HTTPClientError):
    # полный аналог nginx-специфичного статуса 499 - https://httpstatuses.com/499
    status_code = 499


@web.middleware
async def error_middleware(request, handler):
    try:
        return await handler(request)
    except web.HTTPException as ex:
        if ex.status_code >= 500:
            text = await request.text()
            log.exception(ex, body=text, code=ex.status_code, url=request.url, method=request.method)
        elif ex.status_code >= 400:
            text = await request.text()
            log.warning(ex, body=text, code=ex.status_code, url=request.url, method=request.method)
        return ex
    except ClientConnectorError as e:
        log.exception(e)
        return web.HTTPServiceUnavailable(text=f'Недоступен модуль или внешний сервис на {e.host}:{e.port}')
    except CancelledError as e:
        # Здесь обрабатывается ситуация когда, например, был вызван quote
        # а там дергается пачка вызвов к аксапте и система ждёт futures
        # и если эти асинхронные ХТТП-вызовы исполняются долго и в это время клиент жмёт Ctrl-C
        # то недождавшаяся фьючерсов aiohttp бросает это исключение и оно долетает до сюда.
        # В таких ситуациях:
        # - ошибка 499 регистрируетеся в прометеусе
        # - ошибка 499 светится в access log
        # - клиенту наружу этот статус код 499 не отдаётся, так как уже некому отдавать
        # Пример лога:
        # [warning] HTTP client prematurely cancelled the request, status code 499 to be logged [compel_shared.app] @timestamp=2021-02-12T14:45:47.921955 method=POST url=URL('http://localhost:8087/api')
        # [warning] POST /api [http.access] @timestamp=2021-02-12T14:45:47.923496 duration=14.344000000040978 method=POST query=[] remote=::1 request_id=LkPPLQP response={'length': 0, 'status': 499}
        # Тикет:
        # https://app.clickup.com/t/dn3m5u
        log.warning(f'HTTP client prematurely cancelled the request, status code 499 to be logged',
                    url=request.url, method=request.method)
        return HTTPError499()
    except BaseException as ex:
        # Ловим BaseException потому что существуют исключения подобные CancelledError унаследованные не от Exception.
        # И если они, неотловленные, пройдут дальше, то мы столкнёмся с ситуацией когда прометеус своим фильтром
        # зафиксирует ошибку 500, а в access log её не будет.
        text = await request.text()
        log.exception(ex, body=text, url=request.url, method=request.method)
        return web.HTTPInternalServerError(text=str(ex))


@web.middleware
async def log_request_middleware(request: Request, handler):
    """Логгирует запрос сразу по возникновению"""
    if regexp := request.app.log_request_regexp:
        method = request.method
        if (method == 'GET' and regexp.get('GET') and re.search(regexp['GET'], request.path)) or \
                (method == 'POST' and regexp.get('POST') and re.search(regexp['POST'], request.path)) or \
                (method == 'PUT' and regexp.get('PUT') and re.search(regexp['PUT'], request.path)) or \
                (method == 'DELETE' and regexp.get('DELETE') and re.search(regexp['DELETE'], request.path)):
            body = ''
            if method != 'GET':
                try:
                    body = await request.json()
                except:
                    # not an error, there is just no json body
                    pass
            log.info(f'Processing request',
                     method=request.method,
                     raw_path=request.raw_path,
                     body=body,
                     remote=request.remote,
                     request_id=getattr(request, 'request_id', None))
    return await handler(request)


def create_app(routes, **kwargs):
    async def on_cleanup_remove_pid_file(app):
        remove_file_safe(pid_file)

    service_dir = kwargs.get('service_dir') or os.getcwd()
    pid_file = os.path.join(service_dir, '.pid')
    write_file_safe(pid_file, str(os.getpid()))

    venv_static_path = os.path.join('/venv/lib', site.USER_SITE.split('lib/')[-1], 'static')
    app = web.Application(handler_args=dict(access_log_class=StructAccessLogger,
                                            access_log=get_logger('http.access')),
                          client_max_size=int(CLIENT_MAX_SIZE))
    app.add_routes(routes)

    on_startup = kwargs.pop('on_startup', None)
    on_cleanup = kwargs.pop('on_cleanup', None)
    if on_startup:
        app.on_startup.append(on_startup)
    if on_cleanup:
        app.on_cleanup.append(on_cleanup)
    app.on_cleanup.append(on_cleanup_remove_pid_file)

    swagger_path = f'{DOCS_PATH}'
    while swagger_path.endswith('/'):
        swagger_path = swagger_path[:-1]

    setup_aiohttp_apispec(app=app,
                          url=f'{swagger_path}/swagger.json',
                          swagger_path=f'{swagger_path}',
                          static_path=f'{swagger_path}{venv_static_path}',
                          **kwargs)
    if PROMETHEUS_MULTIPROC_PATH:
        app.middlewares.append(hrprometheus_middleware(RequestMonitor))
        Gauge("version", "Service Version", ["service", "shared"]).labels(versioneer.get_version(), shared_version).set(
            1)
    # XXX Теперь ставлю "add_request_id_middleware" перед "error_middleware"
    #  т.к. "add_request_id_middleware" очищает "request_id" в конце своей работы
    #  а "request_id" нам нужен для логгирования из "error_middleware"
    app.middlewares.append(add_request_id_middleware)
    app.log_request_regexp = {}
    app.middlewares.append(log_request_middleware)
    app.middlewares.append(error_middleware)
    app.middlewares.append(validation_middleware)

    for k in env._values:
        val = env._values[k]
        log.info(f'{k}={val}', key=k, value=val)

    log.info(f'API path : {API_PATH}')
    log.info(f'Home path : {HOME_PATH}')
    log.info(f'Docs path : {DOCS_PATH}')
    log.info(f'Swagger path : {swagger_path}')

    return app
