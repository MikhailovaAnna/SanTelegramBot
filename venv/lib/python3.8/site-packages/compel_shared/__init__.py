import re
import secrets
from contextlib import contextmanager

import json
import math
import os
from io import StringIO

import yaml
from datetime import datetime
from decimal import Decimal, DecimalException
from functional import seq
from funcy import get_in, set_in
from structlog import get_logger  # Use structlog here directly to prevent cyclic dependency
from time import time
from typing import Dict, Union, TypeVar, List, Optional, Type

from ._version import get_versions

log = get_logger(__name__)

T = TypeVar('T')


_es_escape = {'\\', '+', '-', '!', '(', ')', ':', '^', '[', ']', '\"', '{', '}', '~', '*', '?', '|', '&', '/'}


def normalize_search_line(s: str):
    if not s:
        return s
    s = s.replace('\t', ' ')
    s = re.sub(' +', ' ', s)
    s = s.strip()
    return s


def strip_safe(s: str):
    """Безопасный strip строки"""
    return s.strip() if isinstance(s, str) else s


def es_escape(s: str):
    buf = StringIO()
    for ch in s:
        if ch in _es_escape:
            buf.write('\\')
        buf.write(ch)
    return buf.getvalue()


def short_uid() -> str:
    """
    Generate a short string UID like "a7zN5Iu"
    """
    return secrets.token_urlsafe(10).replace('_', '').replace('-', '')[:7]


def get_train_template(entities: list, line: str) -> str:
    line = list(line)

    for en in reversed(sorted(entities)):
        from_, to, entity = en
        line[from_:to] = f'${{{entity}}}'

    return ''.join(line)


def dict_subset(d: Dict, *keys):
    """
    Extract subset from dictionary with given keys

    :param d: dictionary
    :param keys: keys
    :return: subset
    """
    return {k: d[k] for k in keys if k in d}


def as_list(v):
    if not isinstance(v, list):
        return [v]
    return v


def append_dict(d: Dict, k: str, value, scalar=False):
    if k not in d:
        d[k] = []
    else:
        d[k] = as_list(d[k])
    value = as_list(value)
    for v in value:
        if v not in d[k]:
            d[k].append(v)
    if scalar and (len(d[k]) == 1):
        d[k] = d[k][0]


def get_by_path(d: Dict, path: str, default=None):
    return get_in(d, path.split('.'), default)


def get_i18n_name(d: Dict, path, locale):
    """
    Return localized string by the given path.
    If locale not found than first found string returned.
    @param d:
    @param path:
    @param locale:
    @return:
    """
    name = get_by_path(d, f'{path}.{locale}')
    if not name:
        name_map = get_by_path(d, path)
        if name_map:
            return list(name_map.values())[0]
    return name


def flatten_dict(input, separator='$', prefix=None, out=None, keep_keys_without_values=False,
                 unlist_single_values=True, flat_lists=True):
    """
    Converts dictionary into plain key/value form
    @param input:
    @param separator:
    @param prefix:
    @return:
    """
    if out is None:
        out = {}
    if input == {} and prefix and keep_keys_without_values:
        out[prefix] = {}
    else:
        for key, value in input.items():
            if key.startswith('$'):
                if not prefix in out:
                    out[prefix] = {}
                out[prefix][key] = value
            else:
                path = f'{prefix}{separator}{key}' if prefix else key
                if not isinstance(value, list):
                    value = [value]
                    is_list = False
                else:
                    is_list = True
                for v in value:
                    if isinstance(v, dict) and (flat_lists or (not flat_lists and not is_list)):
                        flatten_dict(v, separator=separator, prefix=path, out=out,
                                     unlist_single_values=unlist_single_values, flat_lists=flat_lists)
                    else:
                        if not path in out:
                            if unlist_single_values:
                                out[path] = v
                            else:
                                out[path] = v if not is_list else [v]
                        else:
                            if isinstance(out[path], list):
                                out[path].append(v)
                            else:
                                out[path] = [out[path], v]
    return out


def unflatten_dict(d, splitter='$'):
    """
    Unflatten plain dict with compound keys to tree-like dictionary.
    Duplicate keys are converted to lists.
    @param d:
    @param splitter:
    @return:
    """

    def find_dict(node, subkey):
        return seq(node[subkey]).find(lambda e: isinstance(e, dict))

    out = {}
    for k in d:
        path = k.split(splitter)
        val = d[k]
        node = out
        while len(path) > 0:
            subkey = path[0]
            if len(path) == 1:
                if not subkey in node:
                    node[subkey] = val
                elif isinstance(node.get(subkey), list):
                    node[subkey].extend(as_list(val))
                else:
                    node[subkey] = [node[subkey]] + as_list(val)
            else:
                if not subkey in node:
                    node[subkey] = {}
                if isinstance(node[subkey], list):
                    next_node = find_dict(node, subkey)
                    if next_node is None:
                        node[subkey] = [{}] + node[subkey]
                        node = find_dict(node, subkey)
                    else:
                        node = next_node
                elif isinstance(node[subkey], dict):
                    node = node[subkey]
                else:
                    node[subkey] = [{}, node[subkey]]
                    node = node[subkey][0]
            path = path[1:]
    return out


def get_opt_params(query: Dict, *keys, missing_value=None):
    return [query.get(k, missing_value) for k in keys]


def as_list(v):
    if isinstance(v, list):
        return v
    return [v]


@contextmanager
def timing(description: str) -> None:
    start = time()
    yield
    elapsed = time() - start
    log.info(f"{description} timing: {elapsed:.2f}s")


def json_encode(obj):
    if isinstance(obj, Decimal):
        return float(obj)
    elif isinstance(obj, datetime):
        return obj.isoformat()
    return str(obj)


def json_dumps(o, **kwags):
    return json.dumps(o, default=json_encode, ensure_ascii=False, **kwags)


def schema_dumps(obj) -> str:
    """
    дампит объект в json-строку по схеме
    действие а-ля ExtQuote.Schema().dumps(q1, ensure_ascii=False, default=json_encode)
    """
    return obj.__class__.Schema().dumps(obj, ensure_ascii=False, default=json_encode)


def schema_loads(schema_class: Type[T], s: str) -> T:
    """
    читает объект из json-строке по заданной схеме
    действие а-ля UnitsConfig.Schema().load(dic)
    """
    dic = json.loads(s)
    return schema_class.Schema().load(dic)


def schema_load(schema_class: Type[T], dic: dict) -> T:
    """
    конвертирует словарь в объект схемы
    """
    return schema_class.Schema().load(dic)


def as_mongo_query(o: dict):
    res = {}
    for k in o:
        if isinstance(o[k], dict):
            val = as_mongo_query(o[k])
            for k1 in val:
                res[f'{k}.{k1}'] = val[k1]
        else:
            val = o[k]
            if k == 'id':
                k = '_id'
            res[k] = val
    return res


def load_yml(relative_to_file, path):
    file = f'{os.path.dirname(relative_to_file)}/{path}'
    with open(file, 'r') as stream:
        return yaml.load(stream, yaml.FullLoader)


def format_float(x, valuable_digits=2):
    if x == 0 or not (isinstance(x, float) or isinstance(x, Decimal)):
        return str(x)
    log = int(math.log10(abs(x)))
    digits = max(valuable_digits - log, 0)
    return f'{{:.{digits}f}}'.format(x)


def get_locale(request, default='ru'):
    raw_locale = request.headers.get("Accept-Language")
    if not raw_locale:
        locale = default
    else:
        if raw_locale == '*':  # replace wildcard with default locale
            locale = default
        else:
            locale = raw_locale.split(',')[0]  # первый - наиболее предпочтительный, с весом q=1
            locale = locale.split(';')[0]  # отделяем вес от обозначения (пример: en;q=0.9)
            locale = locale.split('-')[0]  # отделяем подтег (пример: en-US)
    return locale


__version__ = get_versions()['version']
del get_versions


def translate_from_index_to_text(line_and_entities):
    """
        Convert line from file in .data to text entities form
        @param line_and_entities:
        @return:
    """
    line = line_and_entities[0]
    entities = line_and_entities[1]["entities"]
    dict_entities = {}
    for ent in entities:
        dict_entities[ent[2]] = [line[ent[0]:ent[1]]]
    return {"line": line, "entities": dict_entities}


def translate_file_to_text(path):
    """
        Convert file from .data to list of text entities form
        @param path:
        @return:
    """
    result_list = []
    with open(path, "r") as read_file:
        lines = json.load(read_file)
        for line in lines:
            res = translate_from_index_to_text(line)
            result_list.append(res)
    result_dict = {"lines": result_list}
    return result_dict


def is_number(value) -> bool:
    """
    Проверяет тип параметра числовой/строковый
    :param value: значение параметра
    :return: возвращает True для числовых типов, False для остальных типов
    todo вот этого должно быть достаточно: isinstance(value, Number) -
     int, float и Decimal детектятся
    """
    return isinstance(value, (int, float, Decimal))


def is_floatable(value) -> bool:
    try:
        float(value)
        return True
    except (TypeError, ValueError):
        return False


def is_intable(value: str) -> bool:
    try:
        int(value)
        return True
    except (TypeError, ValueError):
        return False


def to_int_or_float(value: Union[str, List[str]]) -> Union[int, float, str, list]:
    if is_intable(value):
        return int(value)
    elif is_floatable(value):
        return float(value)
    elif isinstance(value, list):
        return [to_int_or_float(x) for x in value]
    return value


def to_decimal(value, default: T = None) -> Union[Decimal, T]:
    if value is None:
        return default

    try:
        if isinstance(value, float):
            # because Decimal(str(1.00000001)) == Decimal('1.00000001')
            res = Decimal(str(value))
        else:
            res = Decimal(value)

        if res is None or res.is_nan():
            res = default

        return res
    except (DecimalException, ValueError, TypeError):
        return default


def to_int(val, default: Optional[int]):
    try:
        return int(val)
    except (TypeError, ValueError):
        return default


def dotted_keys_to_nested(dict_):
    """
    Transforms {'a.b': 1} to {'a': {'b': 1}},
    {'a.b': {'c.d': 1}} to {'a': {'b': {'c': {'d': 1}}}}, etc
    """
    result = {}

    for key, value in dict_.items():
        value = (
            dotted_keys_to_nested(value) if isinstance(value, dict) else value)
        result = set_in(result, key.split('.'), value)

    return result


def to_float(value) -> Union[float, None]:
    try:
        return float(value)
    except (TypeError, ValueError):
        return None


def first_float(value) -> Union[float, None]:
    if not isinstance(value, list):
        return to_float(value)
    else:
        for val in value:
            res = to_float(val)
            if res is not None:
                return res
    return None


def write_file_safe(file_name: str, value, mode='w'):
    try:
        with open(file_name, mode) as fd:
            fd.write(value)
    except:
        log.error(f'Failed writing to file {file_name}')


def remove_file_safe(file_name: str):
    if os.path.exists(file_name):
        try:
            log.debug(f'Removing file {file_name}')
            os.remove(file_name)
        except:
            log.error(f'Failed removing file {file_name}')


def chunked(lst: list, n: int, yield_last=False):
    length = len(lst)
    for i in range(0, length, n):
        end = i + n
        last = end >= length
        if yield_last:
            yield lst[i:end], last
        else:
            yield lst[i:end]


async def async_chunked(iterable, chunk_size: int):
    chunk = []
    async for x in iterable:
        chunk.append(x)
        if len(chunk) >= chunk_size:
            yield chunk
            chunk = []
    if chunk:
        yield chunk
