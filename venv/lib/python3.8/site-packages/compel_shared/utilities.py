import re
from aiohttp import web
from datetime import datetime
from funcy import collecting, silent
from operator import itemgetter
from types import FunctionType
from typing import Dict, Mapping, List

from compel_shared import json_dumps, dict_subset
from compel_shared.model import normalize_name, sid, DB, create_or_update_doc


def stringify_param(p):
    if type(p) == bool:
        return str(p).lower()
    return str(p)


def stringify_params(params):
    return {k: stringify_param(params[k]) for k in params}


def unstringify_param(p):
    if isinstance(p, dict) or isinstance(p, Mapping):
        return {k: unstringify_param(p[k]) for k in p}
    elif isinstance(p, list):
        return [unstringify_param(v) for v in p]
    elif isinstance(p, str):
        pl = p.lower()
        if pl == 'true':
            return True
        elif pl == 'false':
            return False
    return p


def pick_errors(*errors):
    """
    Pick errors codes and text from web.HTTPxxx exception/text tuples.
    @param errors:
    @return:
    """
    out = {}
    for err in errors:
        code, text = err
        code = code.status_code
        if code in out:
            out[code]['description'] += '\n' + text
        else:
            out[code] = dict(description=text)
    return out


def raise_http(err_tuple):
    """
    Raise HTTPException from tuple class/text definition.
    @param err_tuple:
    """
    raise err_tuple[0](text=err_tuple[1])


def json_response(data: Dict, **kwargs):
    return web.json_response(data, dumps=json_dumps, **kwargs)


class Lowercaser:
    """
    Инструмент для перевода в нижний регистр строк, значений list'ов и dictionary
    """

    def to_lowercase(self, item):
        if isinstance(item, dict):
            return self._dict_to_lowercase(item)
        elif isinstance(item, list):
            return self._list_to_lowercase(item)
        elif isinstance(item, str):
            return item.lower()
        else:
            return item

    def _list_to_lowercase(self, input_list: list):
        return [self.to_lowercase(item) for item in input_list]

    def _dict_to_lowercase(self, input_dict: dict):
        out = {}
        for k, v in input_dict.items():
            out[k] = self.to_lowercase(v)
        return out


_lowercaser = Lowercaser()


def to_lowercase(item):
    return _lowercaser.to_lowercase(item)


class QueryParser:

    def __init__(self, known_fields, exclude_fields=()):
        self.exclude_fields = set(exclude_fields)
        self.known_fields = set(known_fields + ['ids', 'exclude_ids']) - self.exclude_fields

    def _get_known_params0(self, query, multi_name, normalize=True):
        match_query = {}
        for param_k in self.known_fields:
            param_v = query.get(param_k)
            if param_v:
                if param_k == 'name':
                    k = 'names.value_norm' if multi_name else 'name_norm'
                    match_query[k] = normalize_name(param_v) if normalize else param_v
                elif param_k == 'ids' or param_k == 'exclude_ids':
                    id_list = param_v.split(',')
                    update_key = '$in' if param_k == 'ids' else '$nin'
                    if match_query.get('_id'):
                        match_query['_id'].update({update_key: id_list})
                    else:
                        match_query['_id'] = {update_key: id_list}
                elif param_k == 'id':
                    match_query['_id'] = param_v
                else:
                    match_query[param_k] = param_v
        return match_query

    def _get_known_params(self, query):
        raise NotImplementedError()

    def _get_optional_params(self, query):
        optional_fields = set(query) - self.known_fields - self.exclude_fields - {'limit'}
        return {f'params.{k}': query[k] for k in optional_fields}

    def parse(self, query):
        query = unstringify_param(query)
        match = {}
        match.update(self._get_known_params(query))
        match.update(self._get_optional_params(query))
        return match


class QueryParserLocal(QueryParser):

    def _get_known_params(self, query):
        return self._get_known_params0(query, multi_name=True)


class QueryParserExternal(QueryParser):

    def _get_known_params(self, query):
        return self._get_known_params0(query, multi_name=False)

    @staticmethod
    def parse_name(query):
        name = query.get('name')
        if name:
            return normalize_name(name)
        else:
            return None


class BodyParser:

    def __init__(self, alt_keys, key='id'):
        self.key = key
        self.alt_keys = alt_keys

    def _validate_request(self, data):
        primary_key_exists = data.get(self.key, False)
        axapta_id_exists = data.get('axapta_id', False)
        alt_key_values_exist = all(
            [data.get(alt_key, False) for alt_key in self.alt_keys]
        )
        if not (primary_key_exists or alt_key_values_exist or axapta_id_exists):
            raise web.HTTPBadRequest(text='Failed to identify product. Provide id, axapta_id or mpn+manufacturer')

    def _get_params(self, data):
        return [(k, v) for (k, v) in data.items() if k != self.key]

    def _create_filter_query(self, data):
        key = data.get(self.key)
        axapta_id = data.get('axapta_id')
        if key:
            return {'_id': key}
        elif axapta_id:
            return {'axapta_id': axapta_id}
        else:
            return {alt_key: data[alt_key] for alt_key in self.alt_keys}

    def _create_update_query(self, data):
        update_query = {}
        set_query = {}
        id = sid.generate()
        update_query['$setOnInsert'] = {'_id': id, 'created': datetime.now()}

        for param_k, param_v in self._get_params(data):
            if param_k == 'names':
                normalized_names = []
                for name_dict in param_v:
                    name = name_dict['value']
                    name_norm = normalize_name(name_dict['value'])
                    source_type = name_dict['source_type']
                    normalized_names.append({
                        'value': name,
                        'value_norm': name_norm,
                        'source_type': source_type
                    })
                update_query['$addToSet'] = {'names': {'$each': normalized_names}}
            else:
                set_query[param_k] = param_v

        set_query['updated'] = datetime.now()
        update_query['$set'] = set_query
        return update_query

    def parse(self, data):
        self._validate_request(data)
        filter_query = self._create_filter_query(data)
        update_query = self._create_update_query(data)
        return filter_query, update_query


class BodyParserExternal(BodyParser):

    def _create_update_query(self, data):
        update_query = {}
        set_query = {}
        id = sid.generate()
        update_query['$setOnInsert'] = {'_id': id, 'created': datetime.now()}

        for param_k, param_v in self._get_params(data):
            if param_k == 'name':
                set_query['name'] = param_v
                set_query['name_norm'] = normalize_name(param_v)
                set_query[param_k] = param_v
            elif param_k == 'provider_manufacturer':
                set_query[param_k] = param_v in [
                    'True', 'true', 'TRUE', 'да', 'ДА', 'да', 1, True
                ]
            else:
                set_query[param_k] = param_v

        set_query['updated'] = datetime.now()
        update_query['$set'] = set_query
        return update_query

    def _validate_request(self, data):
        primary_key_exists = data.get(self.key, False)
        alt_key_values_exist = all(
            [data.get(alt_key, False) for alt_key in self.alt_keys]
        )
        if not (primary_key_exists or alt_key_values_exist):
            raise web.HTTPBadRequest(text='Failed to identify product. Provide id or mpn+manufacturer+provider')


def any_of(source_list, destination: str):
    '''
    Check whether or not any item from <source_list> is present in <destination>
    Example: source_list = ['a', 'b', 'c', 'd'], destination1 = 'qwera', destination2 = 'yuiop'
    any_of(source_list, destination1) == True; any_of(source_list, destination2) == False
    :param source_list: list of strings
    :param destination: string to look for any of the items from <source_list>
    :return: True if item is present in <destination>, else False
    '''
    return any([True for x in source_list if x in destination])


def has_cyrillic(string):
    return bool(re.search('[а-яА-ЯёЁ]', string))


def silent_pluck(prop, seq):
    return map(silent(itemgetter(prop)), seq)


@collecting
def to_default_param_code_path(import_param_name: str):
    param_path = re.split('\s+|-|<sub>|</sub>', import_param_name)
    for name in param_path:
        code = name
        if code.istitle():
            code = code.lower()

        code = re.sub(r'\W+', '', code)
        if code:
            # code = unidecode(code)
            lang = 'ru' if has_cyrillic(name) else 'en'
            yield dict(code=code, name={lang: name})


def create_default_param(path: List[Dict]):
    param = {}
    node = param
    for path_node in path:
        if node:
            subcode = path_node['code']
            node['nested'] = {subcode: {}}
            node = node['nested'][subcode]
        node.update(path_node)
    return param


def list_declared_class_props(class_: type):
    """
    List properties explicitly declared in a class, with inheritance.
    Excluded: __special_slots__, inner classes, functions.
    """

    def is_prop(name):
        val = getattr(class_, name)
        if name.startswith('__'):
            return False
        if val is None:
            return True
        if isinstance(val, type):
            return False
        if isinstance(val, FunctionType):
            return False
        return True

    return set([p for p in dir(class_) if is_prop(p)])


UPDATE_PARAM_PROPS = {'name', 'full_name', 'recog', 'search', 'providers', 'recognized',
                      'weight'}  # `code` здесь нет т.к. он проставляется отдельно


async def update_param(db: DB, param: Dict):
    """
    Update param given its data, set and create all needed parents according to code.
    @param db:
    @param param:
    """
    path = param['code'].split('$')
    node_path = []
    parent_id = None
    for i, node in enumerate(path):
        node_path.append(node)
        node_code = '$'.join(node_path)
        query = dict(code=node_code)
        update = {}

        if i >= len(path) - 1:
            update.update(dict_subset(param, *UPDATE_PARAM_PROPS))

        update['code'] = node_code

        if parent_id:
            update['parent_id'] = parent_id
        resp = await create_or_update_doc(db.param, query, {}, update)
        parent_id = resp.upserted_id
        if not parent_id:
            node = await db.param.find_one(query, projection=dict(_id=1))
            parent_id = node['_id']


async def update_is_bound_in_class_import_hierarchy(db, start_node_id):
    class_import = db.get_collection('classes_import')

    start_node = await class_import.find_one({'_id': start_node_id})

    children = await class_import.find(
        {'parent_id': start_node_id}).to_list(None)

    is_bound = (
        all(silent_pluck('is_bound', children)) if children
        else bool(start_node.get('target_id'))
    )
    was_bound = bool(start_node.get('is_bound'))

    if is_bound == was_bound:
        return

    await class_import.update_one(
        {'_id': start_node_id}, {'$set': {'is_bound': is_bound}})

    parent_id = start_node.get('parent_id')

    if parent_id:
        await update_is_bound_in_class_import_hierarchy(db, parent_id)


def create_dict_structure(root: Dict, path: List[str]) -> Dict:
    """
    Создаёт структуру вложенных словарей согласно пути `path` внутри словаря `root`.
    Создаёт только то что не существовало до вызова. Возвращает последний из словарей.
    """
    for name in path:
        sub_dict = root.get(name)
        if sub_dict is None:
            root[name] = sub_dict = dict()
        root = sub_dict
    return root
