from decimal import Decimal
from typing import Dict, List, Any

from dataclasses import field
from marshmallow import fields
from marshmallow_dataclass import dataclass

from compel_shared import load_yml, get_by_path, get_i18n_name, dict_subset
from compel_shared.logger import get_logger
from compel_shared.params.alt_format import alt_format_table
from compel_shared.params.unit import UnitConfig
from compel_shared.schema import (
    DecimalField,
    OrderedSchema,
    MultilangField,
    PercentField,
    MongoIDSchema,
    Fuziness, Weight, Samples, Multilang, pick_field_data, WeightField,
)

log = get_logger(__name__)


@dataclass
class RangeConfig:
    min: Decimal = field(default=None, metadata=dict(marshmallow_field=DecimalField(title='Минимальное значение')))
    max: Decimal = field(default=None,
                         metadata=dict(marshmallow_field=DecimalField(title='Максимальное значение', allow_none=True)))


@dataclass(base_schema=OrderedSchema)
class RangeGaussConfig:
    mode: str = field(default='=', metadata=dict(
        title='Режим поиска',
        description='''Выбор режима поиска:
* `=` - точное соответствие;
* `Gauss` - поиск с допуском;
* `>=`, `>`, `<`, `<=` - поиск с условием.
Если задано, то выражение применяется к искомому значению.
Например, если задано `<=` для параметра `Допуск` и искомом значении `5`, то будут найдены продукты с допусками 5% и меньше.
''',
        enum_values=['>=', '>', '<', '<=', 'Gauss', '='],
    ))

    offset: int = field(default=0, metadata=dict(marshmallow_field=PercentField(
        title='Смещение',
        description='''
        Отклонение на эту величину в каждую сторону от оригинального значения не приводит к снижению
        релевантности результатов. Проценты от оригинального значения, [0..100].
        ''')))

    scale: int = field(default=1, metadata=dict(marshmallow_field=PercentField(
        title='Расстояние',
        description='''
        Расстояние от оригинального значения (после "смещения") в каждую сторону, на котором релевантность
        результатов падает до 0 с учётом параметра "затухание". Проценты от оригинального значения, [0..100].
        ''')))

    decay: int = field(default=1, metadata=dict(marshmallow_field=PercentField(
        title='Затухание',
        description='''
        Коэффициент затухания релевантности при отклонении от оригинального значения в каждую сторону, при нахождении
        значения на отрезке "расстояние". Проценты от 0 до 100, где 50 соответствует decay 0.5.
        ''')))


@dataclass(base_schema=OrderedSchema)
class VariablesConfig:
    N: List[str] = field(default=None, metadata=dict(
        title='$Nx',
        description='''
Рег. выражения для настраиваемых переменных типа `measurement`. 
'''
    ))
    S: List[str] = field(default=None, metadata=dict(
        title='$Sx',
        description='''
Рег. выражение для настраиваемых переменных типа `string`
'''
    ))


@dataclass(base_schema=OrderedSchema)
class AltConfig:
    type: str = field(default=None, metadata=dict(title='Тип',
                                                  description='''
Типы альтернативного формата:
* mid - строки с множителем в середине вида 2K2 (напр. сопротивление)
* right - строки с единицами справа вида 0.01UF (напр. емкость)

Следующие форматы используются только для печати значений и при разборе строки выдают всю строку целиком:
* array - для вывода нескольких значениий параметра в строку
* max - для вывода максимального значения
* template - вывода значения из шаблона
''',
                                                  enum_values=list(alt_format_table.keys())))
    unit: str = field(default=None, metadata=dict(title='Единица измерения',
                                                  description='''
Базовая единица измерения (без множителя).
''', ))
    separator: str = field(default=None, metadata=dict(title='Разделитель',
                                                       description='''
Символ-разделитель для списочного формата типа `array`
                                                       '''))
    template: str = field(default=None, metadata=dict(title='Шаблон',
                                                      description='''
Шаблон для печати значения в формате типа `template`.
Используйте макрос $V для того чтобы вставить значение, например +-$V%
'''))
    multipliers: Dict[str, str] = field(default=None, metadata=dict(
        title='Коды множителей',
        description='Перечисляются коды и соответствующие им множители',
        enum_key='multipliers',
        allow_none=True,
        modifiable=True))

    ranges: Dict[str, RangeConfig] = field(default=None, metadata=dict(is_hidden=True, title='Диапазоны'))


@dataclass(base_schema=OrderedSchema)
class CustomSelector:
    custom: bool = field(default=False, metadata=dict(
        title='Переопределить',
        description='Если отмечено используются специализированные настройки определенные в классе вместо стандартных'
    ))


@dataclass(base_schema=OrderedSchema)
class UnitSelector(CustomSelector):
    unit_id: str = field(default=None, metadata=dict(
        title='Единицы',
        description='Стандартная конфигурация единиц для выделения значения из строки параметра',
        enum_key='default_units',
        depends_on={'custom': False},
        exclude_from_delta=True,
    ))
    unit_config: UnitConfig = field(default=None, metadata=dict(
        title='Физические величины', depends_on={'custom': True}))


@dataclass()
class TemplatesConfig:
    templates: List[str] = field(default=None, metadata=dict(
        title='Шаблоны',
        as_textarea=True,
        description='''
Шаблоны для выдедления значений из строк параметров.
Пишутся в виде регулярных выражений с расширенным синтаксисом, включающим в себя макросы для разбора
числовых и строковых значений, а также единиц измерения.

Шаблоны указываются в виде списка и применяются в порядке очереди.
Срабатывает первый шаблон который подойдет к строке параметра.
Для разбора значений применяются следующие макросы:
  
  * **N** (number) - выделить числовое значение, такое как `10`, `5.5`, `1,2` или `3/4`.
  * **U** (unit) - выделить единицу измерения c множителем или без, такую как `kV`, `mkA`, `Вт`.
  * **M** (multiplier) - выделить только множитель (без единиц). Использутся для разбора случаев когда в строках опускают единицы, таких как `2.2K`
  * **S** (string) - строчное значение
  
Например, чтобы выделить численное значение с учетом единиц из строки `2.2 кОм` можно использовать выражение:
  
      $N $U 
      
Такое выражение указывает системе что в строке следует разобрать число (с учетом всех возможных форматов его написания) 
и единицы измерения согласно физическим величинам (В,Ф,Ом и т.п.), 
а также их используемым множителям (микро, кило и т.п.) сконфигурированным для данного параметра.    

В качестве регулярных варажений допускается использование любых конструкций согласно
[спецификации регулярных выражений](https://docs.python.org/3.6/library/re.html#regular-expression-syntax),
за исключением групп. Например, если пробел не всегда вcтречается между числом и единицами то можно использовать выражение:
  
      $N\S*$U 
    
При этом символы начала `^` и конца `$` строки добавляются автоматически, указывать их в выражении не нужно.   

Если в распознаваемой строке содержится один или несколько подпараметров, то их имена следует перечислять через `_`.
Чтобы название переменной макроса не путалось с другими символами выражения его помещают в фигурные скобки:
  
      ${N_width}[xX]${N_height}${U}
        
Вложенные параметры также могут быть произвольной глубины, например:
  
      ${N_ac_min}
  
Единица измерения указанная без кода параметра применяется ко всей строке.  
Если единица измерения или множитель относятся к конкретному коду параметра, то она должна быть написана с тем же кодом:

      ${N_min}${U_min}
  
Код параметра назначения автоматически добавляется в качестве суффикса ко всем макросам. Т.е. например если код
назначения `case`, а выражение записано как `$S`, то значение параметра будет записано в параметр с кодом `case`.  
   
В случае если не указан параметр назначения, то код параметра назначения необходимо указывать в явном виде в названии
макроса (со всеми кодами вложенных параметров, если это необходимо), отделяя его через `_`. 
Например:

      ${N_voltage_ac_min}
      
Этим приемом можно пользоваться в случае если в исходной строке содержатся значения для нескольких независимых параметров.
Испольовать макросы без явного указания в них кодов параметров в случае если не задан целевой параметр не допускается.  

  '''))


@dataclass(base_schema=OrderedSchema)
class TemplateSelector(CustomSelector):
    template_id: str = field(default=None, metadata=dict(
        title='Шаблон',
        description='Шаблон распознавания применяется для выделения значения из строки параметра',
        enum_key='default_templates',
        depends_on={'custom': False},
        exclude_from_delta=True,
    ))
    templates: List[str] = field(default=None, metadata={
        **pick_field_data(TemplatesConfig.Schema, 'templates'),
        'depends_on': {'custom': True}
    })


@dataclass(base_schema=OrderedSchema)
class ParamRecog:
    unit_selector: UnitSelector = field(default=None, metadata=dict(
        title='Выбор настроек единиц измерения', unwrap=True))
    template_selector: TemplateSelector = field(default=None, metadata=dict(
        title='Выбор настроек шаблонов распознавания', unwrap=True))
    multipliers: List[str] = field(default=None, metadata=dict(marshmallow_field=fields.List(
        fields.String(enum_key='multipliers'),
        title='Допустимые множители',
        description='''
Указываются возможные множители которые могут применяться в записях значений параметра.
Например, если известно что значения принято записывать только в милли или микровольтах, то следует выбрать множители 1e-3 и 1e-6.
''',
        allow_none=True,
    )))
    split: str = field(default=None, metadata=dict(
        allow_none=True,
        title='Разделитель',
        description='''
Регулярное выражение для разбиения строки параметра на список.
Если не указано, то строка не разбивается.
''',
    ))
    alt: List[AltConfig] = field(default=None, metadata=dict(
        title='Альтернативные форматы',
        description='Используются в случае если значение параметра может записываться в альтернативном формате, например 1K1 вместо 1100'
    ))
    variables: VariablesConfig = field(default=None,
                                       metadata=dict(
                                           title='Выражения для макросов',
                                           description='''
Регулярные выражения для настраиваемых макросов `$N1..$Nn` и `$S1..$Sn` 
которые можно использовать в шаблонах распознавания, помимо стандартных `$S` и `$N`.

Каждое выражение пишется с новой строки. Нумерация строк выражений начинается с 1. 
Например, чтобы подставить первое выражение из списка в шаблоне нужно написать `$S1`,
для подстановки второго выражения из списка - `$S2` и т.д.

Используйте эти настройки в случае если требуются нестандартные правила для разбора строк и числовых значений.   
''',
                                           unwrap=True))

    def __post_init__(self):
        self._alt_formats = None
        self._unit_names = None

    @property
    def alt_formats(self):
        if self._alt_formats is None:
            self._alt_formats = []
            if self.alt:
                for alt in self.alt:
                    if alt and alt.type and alt.type in alt_format_table:
                        data = AltConfig.Schema().dump(alt)
                        args = {k: data[k] for k in data if k not in ['type'] and data[k]}
                        self._alt_formats.append(alt_format_table[alt.type](**args))
        return self._alt_formats

    @property
    def unit_names(self):
        if not self._unit_names:
            param_units = []
            if self.units:
                for lang in self.units:
                    param_units.extend(self.units[lang])
            self._unit_names = set(param_units)
        return self._unit_names


@dataclass(base_schema=OrderedSchema)
class ParameterSearch:
    fuzziness: Fuziness = None
    range: RangeGaussConfig = field(default=None, metadata=dict(
        unwrap=True,
        title="Диапазон поиска"))


@dataclass(base_schema=OrderedSchema)
class ParamAnalytic:
    product_count: int = field(default=0, metadata=dict(
        title='Продуктов',
        description='Количество продуктов с параметром',
        readonly=True))
    samples: Samples = None

    class Meta:
        ordered = True


@dataclass(base_schema=OrderedSchema)
class ParamBase:
    """Общая база для глобальных параметров и параметров класса"""
    name: Multilang = field(default=None,
                            metadata=dict(title='Название', description='Локализованное название параметра'))
    full_name: Dict[str, str] = field(default=None, metadata=dict(marshmallow_field=MultilangField(
        fields.Str(as_textarea=True),
        title='Полное название',
        description='Локализованное полное название параметра',
    )))
    recog: ParamRecog = field(default=None, metadata=dict(
        title='Распознавание'
    ))
    search: ParameterSearch = field(default=None, metadata=dict(
        title='Поиск',
    ))
    providers: List[str] = field(default=None, metadata=dict(marshmallow_field=fields.List(
        fields.String(enum_key='providers'),
        title='Приоритет поставщиков',
        description='Поставщики у которых берется параметр в порядке приоритета'
    )))
    recognized: bool = field(default=False, metadata=dict(title='Распознается',
                                                          description='Если не отмечено, распознанный в поисковой строке параметр не будет использован при поиске продкутов в каталоге.'))
    weight: int = field(metadata={'marshmallow_field': WeightField(allow_none=True, default=100)}, default=100)


@dataclass(base_schema=MongoIDSchema)
class Param(ParamBase):
    # TODO нельзя точки
    code: str = field(default=None, metadata=dict(
        title='Код',
        description='Полный код параметра, включая подпараметры',
        required=False,  # пришлось сделать необязательным т.к. некоторые поля были вынесены в базовый класс
        is_key_field=True,
        unique=True,
    ))
    id: str = field(default=None, metadata=pick_field_data(MongoIDSchema, 'id', required=False, data_key='_id'))
    parent_id: str = field(default=None, metadata=dict(
        title='Родительский параметр',
        description='Из родительского параметра наследуются настройки распознавания',
        as_tree_enum=True,
        enum_key='param_tree_wo_current',
        is_hidden=True
    ))
    analytic: ParamAnalytic = field(default=None, metadata=dict(
        title="Аналитика",
        unwrap=True,
        readonly=True))

    @staticmethod
    def load_defaults() -> Dict:
        data = load_yml(__file__, 'params.yml')
        separator = '$'
        for k in data:
            data[k]['code'] = k
            if separator in k:
                root = data[k.split(separator)[0]]
                root_recog = root.get('recog')
                recog = data[k].get('recog') or {}
                if root_recog:
                    data[k]['recog'] = {**root_recog, **recog}
        return data

    @staticmethod
    def get_info(param_config: Dict, lang: str):
        # root level properties
        info = dict_subset(param_config, 'id')
        if '_id' in param_config:
            info['id'] = param_config['_id']
        unit = get_i18n_name(param_config, 'recog.units', lang)
        if unit:
            info['unit'] = unit[0]
        name = get_i18n_name(param_config, 'name', lang)
        if name:
            info['name'] = name
        info['recognized'] = get_by_path(param_config, f'recognized', False)
        info['values'] = get_by_path(param_config, 'analytic.samples', [])
        return info

    @staticmethod
    def root_code(p):
        if isinstance(p, dict):
            p = p['code']
        return p.split('$')[0]

    class Meta:
        ordered = True
        fields = (
            'id',
            'parent_id',
            'code',
            'name',
            'full_name',
            'analytic',
            'recognized',
            'providers',
            'recog',
            'search',
            'weight',
        )


@dataclass(base_schema=MongoIDSchema)
class ParamSamples:
    """
    Сэмплы параметров каталога ищутся по code
    Сэмплы параметров источников ищутся по provider + name
    """
    id: str = field(metadata=pick_field_data(MongoIDSchema, 'id', data_key='_id'))
    sample: str = field(metadata=dict(
        title='Сэмпл',
        description='Сэмпл параметра',
        required=True,
    ))
    code: str = field(metadata=dict(
        title='Код',
        description='Полный код параметра, включая подпараметры',
        required=False,
    ))
    name: str = field(metadata=dict(title='Название исходного параметра'))
    provider: str = field(metadata=dict(title='Поставщик'))
    class_id: str = field(metadata=dict(title='ID класса',
                                        description='ID класса в каталоге к которому привязан продукт',
                                        example='8Gg33hWQ8'))
    _class: str = field(metadata=dict(data_key='class',
                                      description='Код класса источника',
                                      example='30239'))
