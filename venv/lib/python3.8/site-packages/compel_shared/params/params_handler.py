import logging
from copy import deepcopy
from numbers import Number
from typing import Optional

import math
from functional import seq
from natsort import natsorted

from compel_shared import dict_subset, unflatten_dict, is_number
from compel_shared.classes.classes_signature import _format_float
from compel_shared.conf.config_cache import ConfigCache
from compel_shared.config import LANGS
from compel_shared.params.param import Param, ParamBase, ParamRecog
from compel_shared.utilities import any_of

log = logging.getLogger(__name__)


def _split_value(value, param_name=None):
    """
    Разбиваем float или int значение на значение + множитель; множитель кратен 10^3.
    Например:
    100 -> (100, "1")
    10000 -> (10, "1e3")
    0.0002 -> (200, "1e-6")
    """
    try:
        value = float(value)
    except:
        return str(value), None

    if value <= 0:
        return str(value), None

    number, multiplier = _get_exponent(value, param_name)
    exponent = round(math.log10(multiplier))
    if exponent == 0:
        return number, '1'
    return number, f'1e{exponent}'


_multipliers = sorted([1e-12, 1e-9, 1e-6, 1e-3, 1, 1e3, 1e6, 1e9])


def _get_exponent(value, param_name=None):
    """
    Превращает число в вид `number * 10 ^ (3n)`, при этом
    1 <= number < 1000
    n - одно из [-4, -3, -2, -1, 0, 1, 2, 3].
    Для чисел меньше 1е-9 и больше 1е9 множители ограничены 1е-12 и 1е12 соответственно
    """
    number, multiplier = None, None
    done = False

    if not done and value == 0:
        number, multiplier = 0, 1
        done = True

    if not done and param_name == 'capacitance':
        # http://pt.rbagroup.ru/issues/64376
        # Исправить написание емкости в нанофарадах в строчных значениях параметров
        multiplier = 1e-6 if value >= 10000e-12 else 1e-12
        number = value / multiplier
        done = True

    if not done:
        first, last = _multipliers[0], _multipliers[-1]
        if value < first:
            number, multiplier = value / first, first
        elif value >= last:
            number, multiplier = value / last, last
        else:
            for lower, upper in seq(_multipliers).sliding(2):
                if lower <= value < upper:
                    number, multiplier = value / lower, lower
        done = True

    return round(number, 3), multiplier


class ParamsHandler:
    STR_VALUE_PREFIX = 'S:'
    NUM_VALUE_PREFIX = 'N:'
    VALUE_PREFIXES = (STR_VALUE_PREFIX, NUM_VALUE_PREFIX)

    def __init__(self, config_cache: ConfigCache):
        self.config_cache = config_cache
        self.pc = config_cache.param
        self.sc = config_cache.service_config
        self.cc = config_cache.classes
        self.mt = config_cache.manufacturers
        self.db = config_cache.db
        self.param_resolver = config_cache.recog_resolver
        self.parser_cache = config_cache.parser_cache

    async def get_params(self):
        return await self.pc.get_params()

    async def param_config(self, param: str) -> Param:
        return await self.pc.get_param(param)

    async def product_option(self, product, locale='ru', params=True, details=False, do_names=True, do_description=True):
        keys = ['id', 'mpn', 'manufacturer', 'axapta_id', 'score', '_explanation', 'class',
                'result_type', 'search_type', 'source_type', 'case', 'signature', 'class_id', 'price',
                'axapta_class_id', 'quantity']
        if do_names:
            keys.append('names')
        o = dict_subset(product, *keys)
        if details:
            o.update(dict_subset(product, 'mount', 'analogs'))

        if do_description:
            if descrs := product.get('descriptions'):
                if descr := descrs.get(locale) or descrs.get('en') if locale == 'ru' else descrs.get(locale):
                    o['description'] = descr

        if params:
            params = product.get('params')
            if params:
                params = await self._display_values(params, locale)
                params = unflatten_dict(params)
                o['params'] = params

        man = o.get('manufacturer')
        if man is not None:
            o['manufacturer_name'] = await self.mt.get_man_name(man)
        return o

    async def product_signature(self, prod):
        """
        Render product signature in format {class} {params signature} @ {mpn}
        :param prod:
        """
        pclass = prod.get('class')
        if pclass:
            signatures = await self.pc.get_signatures()
            if pclass in signatures.classes():
                words = [pclass]
                if pclass == 'FERRITE':
                    words.append('BEAD')  # для ферритов в сигнатуре класс должен называться "FERRITE BEAD"
                params = prod.get('params') or {}
                class_config = await self.cc.get_class(pclass)
                if class_config:
                    class_params = list(class_config.params.keys())
                    out_params = seq(class_params).map(lambda p: (p, params[p] if p in params else None)).to_dict()
                    param_signature = signatures.get_for(pclass, out_params)
                    if param_signature:
                        words.append(param_signature)
                    return ' '.join(words)
        return ''

    async def parse_param(self, text: str, param_name: str, class_code: Optional[str], param: ParamBase):
        """
        @param text: source string for parameter
        @param param_name: param's name
        @param class_code: class context
        @param param: must be presented
        @return:
        """
        if param:
            recog = param.recog or ParamRecog()
            param_text_is_valid = await self._valid_param_text(text, param)
            if param_text_is_valid:
                for alt_format in recog.alt_formats:
                    val = alt_format.to_number(text)
                    if val is not None:
                        return val
                parser = await self.parser_cache.get_parser(param_name, class_code, param)
                if parser:
                    return parser(text)
                else:
                    log.error(f'Parser not found for', param_name=param_name, class_code=class_code)

    async def product_name(self, product: dict, lang: str):
        words = [product['mpn'], product['manufacturer']]
        pclass = product.get('class')
        if pclass:
            words.append(pclass)
            # TODO: we should get here class by ID not code!
            class_conf = await self.cc.get_class(pclass)
            name = class_conf.name.get(lang)
            if name:
                words.append(name)
        params = product.get('params')
        if params and isinstance(params, dict):
            for param_k, param_v in params.items():
                param_string = await self._param_as_string(param_k, param_v, lang)
                if param_string:
                    words.append(param_string)
        return ' '.join(words)

    async def product_names(self, product: dict):
        return {lang: await self.product_name(product, lang) for lang in LANGS}

    async def get_all_unit_names(self):
        return await self.pc.all_unit_names()

    async def _display_values(self, params, locale, display_as_array=False, sort=False):
        """
        Отображать значения параметров в виде строки с единицей измерения и приставкой-множителем + в виде значений
        :param params: параметры в виде {param_key: param_value}
        :param locale: язык отображения параметров - используется для отображения единиц измерения и множителей
        :param display_as_array: если True, то значения будут отображаться в виде массива всегда; если False - в виде
        массива будут отображаться несколько значений, а одно значение - в виде {"val": value, "str": param_text}
        :return:
        """
        param_config = await self.pc.get_params()
        out = deepcopy(params)

        def prefixed_param_value(value):
            pfx = self.NUM_VALUE_PREFIX if is_number(value) else self.STR_VALUE_PREFIX
            return f'{pfx}{value}'

        for k, v in params.items():
            if k in param_config:
                if not isinstance(v, list):
                    v = [v]
                param_display = [
                    {
                        'str': await self._param_as_string(k, val, locale),
                        'val': prefixed_param_value(val),
                        'name': await self._param_name_i18n(k, locale),
                    }
                    for val in v
                ]
                if sort:
                    param_display = self._sort_display_values(param_display)
                if not display_as_array:
                    param_display = param_display[0] if len(param_display) == 1 else param_display
                out[k] = param_display
        return out

    @staticmethod
    def _sort_display_values(params):
        if isinstance(params, list) and len(params) > 1:
            return natsorted(params, key=lambda x: x['val'])
        else:
            return params

    async def _valid_param_text(self, param_text, param: ParamBase):
        """
        Проверяем, распознался ли параметр правильно:
        1. юниты, если присутствуют, должны соответствовать юнитам параметра
        2. либо в тексте параметра должен быть один из альтернативных мультиплаеров
        3. если нет ни мультиплаера, ни юнитов - параметр все равно считается корректно распознанным
        4. параметр с типом `string` считается корректно распознанным - не проверяем

        Если в тексте параметра указана единица измерения, не относящаяся к параметру, либо указан неправильный
        множитель альт формата - считаем такой параметр распознанным некорректно.
        """
        if param:
            recog = param.recog or ParamRecog()
            unit_selector = recog.unit_selector
            param_units = []
            if unit_selector:
                unit_id = unit_selector.unit_id
                if unit_id:
                    unit_config = await self.param_resolver.utc.get_unit(unit_id)
                    if unit_config:
                        param_units = unit_config.unit_names
            alt_multipliers = await self._get_alt_multipliers(param)
            all_unit_names = await self.param_resolver.utc.get_unit_names()
            p_text_has_any_units = any_of(all_unit_names, param_text)
            p_text_has_param_units = any_of(param_units, param_text)
            p_text_has_multipliers = any_of(alt_multipliers, param_text)
            if p_text_has_param_units or p_text_has_multipliers or not p_text_has_any_units:
                return True

        return False

    async def _get_alt_multipliers(self, param: ParamBase):
        """
        Извлекаем буквенные множители альтернативных форматов.
        """
        out = []
        if param:
            # XXX вроде `param` всегда true
            try:
                alt_formats = param.recog.alt_formats
                for alt_format in alt_formats:
                    mults = alt_format.mults
                    if mults:
                        out.extend(mults.values())
            except AttributeError:
                pass
        return out

    async def _resolve_units(self, unit_id):
        """
        Возвращает единицы измерения для указанного параметра по его unit_id
        """
        units = {}
        unit_info = await self.param_resolver.utc.get_unit(unit_id)
        if unit_info:
            units = unit_info.units
        return units

    async def _param_name_i18n(self, param_k: str, lang: str) -> Optional[str]:
        param_config = await self.param_config(param_k)
        if param_config:
            name_dict = param_config.name
            if name_dict:
                name = name_dict.get(lang)
                if name:
                    return name
                # если заданного языка не найдено - возвращаем любую локализацию
                for a_lang, a_name in name_dict.items():
                    if a_name:
                        return a_name
        return None

    async def _param_as_string(self, param_k, param_v, lang: str):
        """
        Приводим значение параметра в читаемый вид.
        {'capacitance': [3.3e-8]} -> 33нф

        Схема выбора приставки:
         - 0 - без приставки (0 - "0 ом")
         - 0 < x < 1е-9 - пико- (6e-13 - "0.6пф"; 2.2e-11 - "22пф")
         - 1е-9 ≤ x < 1е-6 - нано- (1e-7 - "100нф")
         - 1е-6 ≤ x < 1е-3 - микро- (5.6e-06 - "5.6мкф")
         - 1е-3 ≤ x < 1 - милли- (0.033 - "33мом")
         - 1 ≤ x < 1е3 - без приставки (100 - "100ом")
         - 1е3 ≤ x < 1е6 - кило- (130000 - "130Ком")
         - 1е6 ≤ x < 1е9 - мега- (6800000 - "6.8Мом")
         - 1е9 ≤ x - гига- (10000000000 - "10Гом")

        Т.е. перед приставкой должно быть число в диапазоне 1 ≤ x < 1е3, за исключением случаев
        со значениями "0 < x < 1е-9" и "1е9 ≤ x"
        """
        if isinstance(param_v, list):
            param_vals = [p for p in param_v if p is not None]
            if len(param_vals) < 1:
                return ''
            else:
                param_v = param_vals[0]
        param_config = await self.param_config(param_k)
        if not param_config:
            return str(param_v)
        else:
            recog = param_config.recog
            if is_number(param_v) and recog:
                unit = ''
                if recog.unit_selector:
                    unit_id = recog.unit_selector.unit_id
                    if unit_id:
                        units = await self._resolve_units(unit_id)
                        units = units.get(lang)
                        if units:
                            unit = units[0]
                if not recog.multipliers:
                    # если у параметра нет мультиплаеров, возвращаем значение "как есть"
                    return f'{_format_float(param_v)}{unit}'
                value, multiplier = _split_value(param_v, param_k)
                value = _format_float(value)
                multiplier = await self._exponent_to_multiplier(multiplier, lang)
                if multiplier is None:
                    return f'{_format_float(param_v)}{unit}'
                else:
                    return f'{value}{multiplier}{unit}'
            else:
                return str(param_v)

    async def _exponent_to_multiplier(self, exponent, lang):
        """
        Конвертируем множители в приставки в зависимости от языка.
        Если для языка нет подходящей приставки - возвращаем None.
        `1e-6` -> `мк`
        `1e3` -> `к`
        """
        unit_conf = await self.sc.get_section('units')
        multipliers = unit_conf.multipliers
        if exponent == '1':
            return ''
        elif exponent not in multipliers:
            return None
        else:
            mults = await self.sc.get_section('units')
            mults = mults.multipliers[exponent].get(lang)
            if mults:
                if isinstance(mults, list):
                    return mults[0]
                else:
                    return mults
            else:
                return None
