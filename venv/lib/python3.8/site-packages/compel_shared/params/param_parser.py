import logging
import re
from decimal import Decimal
from string import Template

from functional import seq
from funcy import omit

from compel_shared import format_float
from compel_shared.conf.units_config import UnitsConfig
from compel_shared.params import number_infix, get_measurement, number_expr
from compel_shared.params.param import ParamRecog

ID_SEP = '·'
SUBFIELD_SEP = '_'
MOD_SEP = 'ː'

VAR_PATTERN_CORE = f'([A-Z]\d*)(?:{SUBFIELD_SEP}([a-zA-Z0-9]\w*))?'
VAR_PATTERN = re.compile(VAR_PATTERN_CORE)
VAR_PATTERN_ID = re.compile(f'^{VAR_PATTERN_CORE}{ID_SEP}(\d+)$')

log = logging.getLogger(__name__)


def get_template_vars(s):
    vars = []

    class DummyDict:
        def __getitem__(self, key):
            vars.append(key)
            return 'X'

    try:
        Template(s).substitute(DummyDict())
    except Exception as e:
        raise Exception(f'Failed to parse template : {s} - {e}')
    return vars


def mult_subgroup(var_id):
    return f'{var_id}{MOD_SEP}m'


def unit_subgroup(var_id):
    return f'{var_id}{MOD_SEP}u'


def is_valid_value(x):
    return x or x == Decimal(0)


class ParamParser:

    def __call__(self, text):
        return text


class BasicParser:
    expr = re.compile(number_expr)

    def __init__(self, measurement=False, default_multiplier=None):
        self.default_multiplier = default_multiplier
        self.measurement = measurement

    def __call__(self, text):
        if self.measurement:
            m = self.expr.match(text)
            if m:
                val = get_measurement(m.group(1))
                if self.default_multiplier:
                    val *= self.default_multiplier
                return val

        else:
            return text


class TemplateParamParser(ParamParser):
    '''
Parse parameters in accordance with configured template(s).
Templates are applied in the order they are defined.
Variables in templates are substituted to create actual parsing regexps.
Parameters can be simple or compound.

Variable types:
    N - numeric value - results in numeric value extraction.
    U - unit - unit with multiplier.
    M - multiplier only - extracted string tells how N needs to be normalized
    S - string - value is extracted as is
    CN - condition measurement - condition at which main measurement was made (e.g. current at 100Hz)
    CU - condition unit - extracted string tells how CM needs to be normalized

Variables of type M,U are written in a format variable type + optional subfield:

    ${var type}_{subfield?}

Subfield is used to parse compound parameters. In that case all variables in templates must have subfields defined.
Suffix tells the parser to copy the extracted value into parameter subfield (e.g. width, min, max e.t.c.).

Examples:

    $M $U - "27 kV" for voltage
    $M_ac $U_ac - "27 kV" for voltage.ac

    '''

    ROOT = '$root'

    def __init__(self, unit_config: UnitsConfig, param_recog: ParamRecog):
        """

        @param unit_config: unit configuration
        @param param_recog: param configuration

        """
        self.expressions = []
        self.param_recog = param_recog

        self.default_multiplier = None
        if param_recog.unit_selector and param_recog.unit_selector.unit_config and param_recog.unit_selector.unit_config.default_multiplier:
            self.default_multiplier = Decimal(param_recog.unit_selector.unit_config.default_multiplier)

        self.precision = None
        if param_recog.unit_selector and param_recog.unit_selector.unit_config and param_recog.unit_selector.unit_config.precision:
            self.precision = int(param_recog.unit_selector.unit_config.precision)

        self.split = param_recog.split
        self.variables = param_recog.variables

        # Multiplier => value map for fast search
        self.mult_map = {}
        multipliers = param_recog.multipliers
        multiplier_defs = unit_config.multipliers
        if multipliers:
            for mult_value in multipliers:
                if mult_value in multiplier_defs:
                    for lang in multiplier_defs[mult_value]:
                        for mult in multiplier_defs[mult_value][lang]:
                            self.mult_map[mult] = Decimal(mult_value)

        def named_group(id, expr):
            return f'(?P<{id}>{expr})'

        units = {}
        if param_recog.unit_selector and param_recog.unit_selector.unit_config:
            units = param_recog.unit_selector.unit_config.units
        self.si_conv_map = unit_config.si_conv_map

        templates = param_recog.template_selector.templates
        if not templates:
            templates = '$S'
            templates = [templates]

        for t in templates:
            vars = get_template_vars(t)
            # Multiple occurrences of same var $M_width will get different ID's - $M_width#0, $M_width#1 e.t.c.
            var_ids = {v: 0 for v in vars}
            context = {}
            for var in vars:
                m = VAR_PATTERN.match(var)
                if m:
                    var_id = f'{var}{ID_SEP}{var_ids[var]}'
                    var_type = m.group(1)
                    var_index = int(var_type[1:]) - 1 if len(var_type) > 1 else None
                    if var_type in ['N', 'CN']:
                        if self.variables and self.variables.N and var_index is not None:
                            expr = self.variables.N[var_index]
                        else:
                            expr = f'([-+]\s*)?\d+([{number_infix}]\d+)?([eE][+-]\d+)?'
                    elif var_type in ['U', 'M', 'CU']:
                        expr = ''
                        if self.mult_map:
                            mult_expr = '|'.join(self.mult_map.keys())
                            mult_expr = named_group(mult_subgroup(var_id), mult_expr)
                            expr += f'{mult_expr}?'
                        if var_type in ['U', 'CU']:
                            unit_expr = '|'.join([u for lang in units for u in units[lang]])
                            unit_expr = named_group(unit_subgroup(var_id), unit_expr)
                            expr += unit_expr
                    else:
                        if self.variables and self.variables.S and var_index is not None:
                            expr = self.variables.S[var_index]
                        else:
                            expr = f'\S.*\S|\S+'

                    # Top level regex groups with ID like N_width#0
                    expr = named_group(var_id, expr)
                    if not var in context:
                        context[var] = []
                    context[var].append(expr)
                    var_ids[var] += 1

            class Context:

                def __init__(self):
                    self.var_ids = {v: 0 for v in vars}

                def __getitem__(self, key):
                    id = self.var_ids[key]
                    self.var_ids[key] += 1
                    return context[key][id]

            expr = Template(t.replace('(', '\(').replace(')', '\)')).substitute(Context())
            self.expressions.append(re.compile(f'^{expr}$'))

    def __call__(self, text):
        """
        Parse text and return values structure as dict or array if values are parsed to root variables.
        @rtype:
        """
        splited_text = re.split(self.split, str(text)) if self.split else [text]
        splited_text = seq(splited_text).map(lambda t: t.strip()).filter(lambda t: t).list()
        field_values = {}

        def round(val):
            if self.precision and isinstance(val, Decimal):
                return Decimal(format_float(val, self.precision))
            return val

        def update(old_values, new_values):
            for key in new_values.keys():
                if key in old_values:
                    old_values[key].extend(new_values[key])
                else:
                    old_values[key] = new_values[key]
            return old_values

        for text in splited_text:
            for expr in self.expressions:
                # 1.1A @ 100Hz  $M\s*$U\s*@\s*$СM\s*$CU
                expr_match = expr.match(text)
                if expr_match:
                    values = {}
                    mults = {}
                    group_dict = expr_match.groupdict()

                    def set_value(field_name, id, val):
                        if field_name not in values:
                            values[field_name] = []
                        if id >= len(values[field_name]):
                            values[field_name].extend([None] * (id + 1 - len(values[field_name])))
                        values[field_name][id] = val

                    # Extract values and multipliers to values/mults
                    for var_id in group_dict:
                        if group_dict[var_id]:
                            # capture top-level groups like M_width
                            m = VAR_PATTERN_ID.match(var_id)
                            if m:
                                var_type, field_name, id = m.groups()
                                id = int(id)
                                is_S_pattern = var_type.startswith('S')
                                is_N_pattern = var_type.startswith('N')
                                if field_name is None:
                                    field_name = self.ROOT
                                if is_N_pattern or (is_S_pattern and re.search(r'^[0-9]+\-[0-9]+\/[0-9]+$', text)):
                                    set_value(field_name, id, get_measurement(group_dict[var_id]))
                                    if self.default_multiplier:
                                        if field_name not in mults:
                                            mults[field_name] = {}
                                        if id not in mults[field_name]:
                                            mults[field_name][id] = self.default_multiplier

                                elif var_type in ['U', 'M']:
                                    if field_name not in mults:
                                        mults[field_name] = {}
                                    mults[field_name][id] = 1
                                    mult_group = mult_subgroup(var_id)
                                    if mult_group in group_dict and group_dict[mult_group]:
                                        mults[field_name][id] *= self.mult_map[group_dict[mult_group]]

                                    if var_type == 'U':
                                        unit_group = unit_subgroup(var_id)
                                        if unit_group in group_dict and group_dict[unit_group]:
                                            unit = group_dict[unit_group]
                                            if unit in self.si_conv_map:
                                                mults[field_name][id] *= Decimal(self.si_conv_map[unit])
                                elif var_type == 'CN':
                                    # TODO: Handle CN/CU type variables
                                    pass
                                elif is_S_pattern:
                                    set_value(field_name, id, group_dict[var_id])

                    # Apply extracted multipliers to values
                    for field_name in values:
                        for id in range(len(values[field_name])):
                            mult = None
                            if field_name in mults and id in mults[field_name]:
                                # Pick multiplier for this specific subfield / ID
                                mult = mults[field_name][id]
                            if not mult:
                                # Pick first found multiplier in group of same ID
                                mult = next(iter([mults[s][id] for s in mults if id in mults[s]]), None)
                            if mult:
                                values[field_name][id] *= mult

                    field_values = update(field_values, values)
                    break

        # Ensure distinct vals in result
        for field_name in field_values:
            seen = set()
            seen_add = seen.add
            vals = [round(x) for x in field_values[field_name]]
            field_values[field_name] = [x for x in vals if not (x in seen or seen_add(x))]
            if len(field_values[field_name]) == 1:
                field_values[field_name] = field_values[field_name][0]

        field_values = {k.replace('_', '$'): field_values[k] for k in field_values}

        if self.ROOT in field_values:
            if len(field_values) > 1:
                field_values = [field_values[self.ROOT], omit(field_values, {self.ROOT})]
            else:
                field_values = field_values[self.ROOT]

        if is_valid_value(field_values):
            return field_values

    def __str__(self):
        return str(self.param_recog.template_selector.templates)
