import re
from decimal import Decimal
from string import Template
from typing import Dict

from functional import seq

from compel_shared.params import D_ONE, D_ZERO, convert_value


class AltFormat:

    def to_number(self, text: str):
        pass

    def to_text(self, value) -> str:
        pass


RUS_ENG_MAPPING = {
    'У': 'Y',
    'К': 'K',
    'А': 'A',
    'В': 'B',
    'Х': 'X',
    'Т': 'T',
    'С': 'C',
    'О': 'O',
    'М': 'M',
    'Р': 'P'
}


def derus(s):
    return ''.join([RUS_ENG_MAPPING.get(c, c) for c in s])


class AltMidFormat(AltFormat):
    """
    Handle unit formats like 2K2.

    """

    def __init__(self, multipliers: Dict[str, float]):
        """
        Alt format configuration example:
          R: 1
          K: 1e3
          M: 1e6
          G: 1e9

        :param multipliers: multipliers config
        """
        self.codes = {m: Decimal(multipliers[m]) for m in multipliers}
        self.mults = {Decimal(multipliers[m]): m for m in multipliers}
        self.grid = seq(self.mults.keys()).sorted().sliding(2).map(lambda x: x.list()).filter(
            lambda x: len(x) > 1).list()
        expr = '|'.join(self.codes.keys())
        expr = f'(\d+)?({expr})(\d+)?'
        self.matcher = re.compile(expr)
        self.code_one = self.mults[D_ONE] if D_ONE in self.mults else ''

    def to_number(self, text: str):
        m = self.matcher.match(derus(text.upper().strip()))
        if m:
            left, code, right = m.groups()
            if left is not None or right is not None:
                mult = Decimal(self.codes[code])
                left = Decimal(left) if left else D_ZERO
                right = Decimal(f'.{right}') if right else D_ZERO
                return (left + right) * mult

    def _format_grid_item(self, value, m1, sign):
        mult = self.mults[m1]
        val = float(value / m1)
        if int(val) == val:
            val = int(val)
        val = str(val)
        return sign + val.replace('.', mult).rstrip('0') if '.' in val else f'{sign}{val}{mult}'

    def to_text(self, value) -> str:
        value = Decimal(str(value)).normalize()
        sign, digits, exponent = value.as_tuple()
        sign = '-' if sign else ''
        if value == 0:
            return f'{sign}0{self.code_one}'
        elif exponent < 0:
            if value > 1:
                int_part, float_part = str(value).replace(',', '.').split('.')
                return f'{sign}{str(int_part)}{self.to_text("0." + float_part)}'
            else:
                digits = ''.join([str(d) for d in digits])
                val = str.rjust(digits, abs(exponent), '0')
                return f'{sign}{self.code_one}{val}'
        else:
            for g in self.grid[:-1]:
                m1, m2 = g
                if value < m2:
                    return self._format_grid_item(value, m1, sign)
            else:
                g = self.grid[-1]
                m1, m2 = g
                if value < m2:
                    return self._format_grid_item(value, m1, sign)
                else:
                    return self._format_grid_item(value, m2, sign)


class AltRightFormat(AltFormat):

    def __init__(self, ranges, unit):
        """
        Multipliers configuration examples:
          P: 1e-12
          U: 1e-6
        :param ranges:
        """
        self.codes = {m: Decimal(str(ranges[m]['min'])) for m in ranges}
        self.mults = {Decimal(str(ranges[m]['min'])): m for m in ranges}
        expr = '|'.join([k for k in self.codes.keys() if k != '-'])
        expr = f'(\d+)(\.\d+)?({expr})?{unit}'
        self.matcher = re.compile(expr)
        self.unit = unit
        self.grid = seq(ranges.values()).map(lambda x: {k: Decimal(str(x[k])) for k in x if x[k]}).sorted(
            lambda v: v['min']).list()

    def to_number(self, text: str) -> Decimal:
        m = self.matcher.match(text.strip())
        if m:
            left, right, code = m.groups()
            mult = Decimal(self.codes[code]) if code else D_ONE
            left = Decimal(left) if left else D_ZERO
            try:
                right = Decimal(right) if right else D_ZERO
            except Exception as e:
                if '/' in right:
                    right = right.replace('/', '')
                    right = Decimal(right) if right else D_ZERO
                    return right * mult
                else:
                    print(str(e))
            return (left + right) * mult

    def to_text(self, value) -> str:
        value = Decimal(str(value))
        sign, digits, exponent = value.as_tuple()
        sign = '-' if sign else ''
        if value == 0:
            return f'{sign}0{self.unit}'
        else:
            for g in self.grid:
                mult = g['min']
                if not 'max' in g or value < g['max']:
                    value = value / mult
                    code = self.mults[mult] if mult != 1 else ''
                    val = f'{value.normalize():f}'
                    return f'{sign}{val}{code}{self.unit}'

        return f'{value}{self.unit}'


class AltArrayFormat(AltFormat):

    def __init__(self, separator):
        self.separator = separator

    def to_text(self, value) -> str:
        return self.separator.join([convert_value(v) for v in value]) if type(value) == list else convert_value(value)


class AltMaxFormat(AltFormat):
    def to_text(self, value) -> str:
        return convert_value(max(value)) if type(value) == list else convert_value(value)


class AltTemplateFormat(AltFormat):

    def __init__(self, template):
        self.template = template

    def to_text(self, value) -> str:
        context = {
            'V': convert_value(value)
        }
        return Template(self.template).substitute(context)


alt_format_table = {
    'mid': AltMidFormat,
    'right': AltRightFormat,
    'array': AltArrayFormat,
    'max': AltMaxFormat,
    'template': AltTemplateFormat
}
