from datetime import datetime
from typing import List

from aiohttp.web import HTTPServiceUnavailable
from gitlab import Gitlab

from compel_shared.config import GITLAB_URL, GITLAB_TOKEN, BRANCH_NAME
from compel_shared.logger import get_logger
from compel_shared.train.schema import ModelState

log = get_logger(__name__)

PIPELINE_FAILED_STATUSES = ['failed', 'canceled', 'skipped']


def get_gitlab_project(project_id):
    if not GITLAB_URL:
        raise HTTPServiceUnavailable(text="GITLAB_URL ENV is not set.")
    if not GITLAB_TOKEN:
        raise HTTPServiceUnavailable(body="GITLAB_TOKEN ENV is not set.")

    gl = Gitlab(GITLAB_URL, private_token=GITLAB_TOKEN)
    return gl.projects.get(project_id)


def get_pipelines(project_id):
    recog_project = get_gitlab_project(project_id)
    try:
        return recog_project.pipelines.list(ref=BRANCH_NAME)
    except Exception as e:
        log.error(f"Gitlab API exception: {e}")
        raise HTTPServiceUnavailable(text="Failed to fetch gitlab pipeline list for recog project")


def get_pipeline_by_id(pipelines: List, pipeline_id: int):
    res = [x for x in pipelines if x.id == pipeline_id]
    return res[0] if res else None


def is_pipeline_failed(pipelines: List, pipeline_id: int):
    pipeline = get_pipeline_by_id(pipelines, pipeline_id)
    if not pipeline or pipeline.status in PIPELINE_FAILED_STATUSES:
        return True
    return False


async def mark_pipeline_failed(db, model_id: str):
    await db.train_model.update_one(
        {'_id': model_id},
        {
            '$set': {
                'state': ModelState.FAILED.value,
                'error_message': 'Gitlab-ci pipeline has failed',
                'updated': datetime.now()
            }
        }, upsert=False)
