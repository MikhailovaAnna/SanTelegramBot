import datetime
import re
from decimal import Decimal
from typing import Dict

from bson.codec_options import CodecOptions
from bson.codec_options import TypeCodec, TypeRegistry
from funcy import cached_property
from pymongo import UpdateOne
from motor.motor_asyncio import AsyncIOMotorClient
from shortid import ShortId

from compel_shared.config import DB_HOST, DB_PORT, DB_NAME, DB_URL
from compel_shared.logger import get_logger

exclude_regexp = r'[!\-+=/\\\(\)\[\]<>{}#,\.@\"\'\?\s]*'
sid = ShortId()

log = get_logger(__name__)


class DecimalCodec(TypeCodec):
    '''
    В монгу децималы складываем как float, обратно забираем как есть
    '''
    python_type = Decimal
    bson_type = float

    def transform_python(self, value):
        return float(value)

    def transform_bson(self, value):
        return value


codec_options = CodecOptions(type_registry=TypeRegistry([DecimalCodec()]))


def create_db(db_name: str = DB_NAME, port: int = DB_PORT):
    if DB_URL:
        return AsyncIOMotorClient(DB_URL)[db_name]
    else:
        return AsyncIOMotorClient(DB_HOST, port)[db_name]


def normalize_name(name):
    # todo белый список получше будет - всех символов не перечислишь
    if not name:
        return name
    return re.sub(exclude_regexp, '', name)[:256]


class DB:

    def __init__(self, db_name: str = DB_NAME, db_port: int = DB_PORT):
        self.db = create_db(db_name, db_port)

    def get_collection(self, name):
        return self.db.get_collection(name, codec_options=codec_options)

    @cached_property
    def local_product(self):
        return self.get_collection('local_product')

    @cached_property
    def ext_product(self):
        return self.get_collection('external_product')

    @cached_property
    def raw_product(self):
        return self.get_collection('raw_product')

    @cached_property
    def search_cache_entry(self):
        return self.get_collection('search_cache_entry')

    @cached_property
    def search_request(self):
        return self.get_collection('search_request')

    @cached_property
    def param(self):
        return self.get_collection('param')

    @cached_property
    def param_import(self):
        return self.get_collection('param_import')

    @cached_property
    def param_samples(self):
        return self.get_collection('param_samples')

    @cached_property
    def classes(self):
        return self.get_collection('classes')

    @cached_property
    def classes_import(self):
        return self.get_collection('classes_import')

    @cached_property
    def manufacturers(self):
        return self.get_collection('manufacturers')

    @cached_property
    def manufacturers_import(self):
        return self.get_collection('manufacturers_import')

    @cached_property
    def manufacturers_renames(self):
        return self.get_collection('manufacturers_renames')

    @cached_property
    def mpn_renames(self):
        return self.get_collection('mpn_renames')

    @cached_property
    def packages(self):
        return self.get_collection('packages')

    @cached_property
    def recog_template(self):
        return self.get_collection('recog_template')

    @cached_property
    def unit_template(self):
        return self.get_collection('unit_template')

    @cached_property
    def train_templates(self):
        return self.get_collection('train_templates')

    @cached_property
    def train_samples(self):
        return self.get_collection('train_samples')

    @cached_property
    def train_sets(self):
        return self.get_collection('train_sets')

    @cached_property
    def train_samples(self):
        return self.get_collection('train_samples')

    @cached_property
    def train_model(self):
        return self.get_collection('train_model')

    @cached_property
    def renaming(self):
        return self.get_collection('renaming')


async def create_or_update_doc(collection, query, data, set_on_insert: Dict = None, unset_keys=None):
    now = datetime.datetime.now()
    data['updated'] = now
    id = sid.generate()
    if query:
        soi = dict(_id=id, created=now)
        if set_on_insert:
            soi.update(set_on_insert)
        update = {
            '$setOnInsert': soi,
            '$set': data
        }
        if unset_keys:
            unset = {}
            for k in unset_keys:
                unset[k] = ""
            update['$unset'] = unset

        try:
            return await collection.update_one(query, update, upsert=True)
        except Exception as e:
            log.exception(f'Failed CRUD', query=query, update=update)
    else:
        data['_id'] = id
        data['created'] = now
        try:
            return await collection.insert_one(data)
        except Exception as e:
            log.exception(f'Failed insert', data=data)


def create_update_one(query, data, set_on_insert: Dict = None, unset_keys=None, upsert=False, add_to_set: Dict = None):
    now = datetime.datetime.now()
    data['updated'] = now
    id = sid.generate()

    soi = dict(_id=id, created=now)
    if set_on_insert:
        soi.update(set_on_insert)
    update = {
        '$setOnInsert': soi,
        '$set': data
    }
    if unset_keys:
        unset = {}
        for k in unset_keys:
            unset[k] = {k: ""}
        update['$unset'] = unset

    if add_to_set:
        update['$addToSet'] = add_to_set

    return UpdateOne(query, update, upsert=upsert)
