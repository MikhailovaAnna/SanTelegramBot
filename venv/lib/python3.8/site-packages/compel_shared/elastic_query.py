import json

from abc import ABC, abstractmethod, ABCMeta
from numbers import Number
from typing import List, Dict, Any


def from_percent(value: float):
    return value / 100


def param_field_from_type(param_name, param_value):
    str_param = f'params.string.{param_name}'
    num_param = f'params.number.{param_name}'
    if isinstance(param_value, list):
        value = param_value[0]
    elif isinstance(param_value, dict):
        value = next(iter(param_value.values()))
    else:
        value = param_value
    return num_param if isinstance(value, Number) else str_param


class QueryNode(ABC):

    @abstractmethod
    def create_query(self):
        raise NotImplementedError

    def __str__(self):
        return json.dumps(self.create_query(), ensure_ascii=False, indent=2)


class FieldNode(QueryNode, metaclass=ABCMeta):
    def __init__(self, field, value):
        self.field = field
        self.value = value


class WeighedNode(FieldNode, metaclass=ABCMeta):
    def __init__(self, field, value, weight: float = None):
        """
        :param field:
        :param value:
        :param weight: 0..100
        """
        super().__init__(field, value)
        self.weight = from_percent(weight) if weight else None


class Term(WeighedNode):
    def create_query(self):
        query = {"term": {self.field: {"value": self.value}}}
        if self.weight:
            query["term"][self.field]["boost"] = self.weight
        return query


class Range(WeighedNode):
    """
    Вырожденный запрос "range" с единственным условием.
    """
    def __init__(self, field, value, weight: float = None, range_op: str = '') -> None:
        super().__init__(field, value, weight)
        self.range_op = range_op

    def create_query(self):
        range_map = {'>=': 'gte', '>': 'gt', '<=': 'lte', '<': 'lt'}
        if self.range_op not in range_map.values():
            self.range_op = range_map[self.range_op]

        query = {'range': {self.field: {self.range_op: self.value}}}
        if self.weight:
            query['range'][self.field]['boost'] = self.weight
        return query


class RangeMany(WeighedNode):
    """
    Запрос "range" с несколькими условиями.
    Пример:
    RangeMany('freq', {'gt': 100.0})
    """
    def __init__(self, field, value: Dict[str, Any], weight: float = None):
        super().__init__(field, value, weight)

    def create_query(self):
        operators = {
            op: value
            for op, value in self.value.items()
        }
        if self.weight:
            operators['boost'] = self.weight
        return {'range': {self.field: operators}}


class Match(FieldNode):
    def create_query(self):
        return {"match": {self.field: self.value}}


class Terms:
    def __init__(self, field, value=None, size: int = 0) -> None:
        self.field = field
        self.value = value
        self.size = size

    def create_query(self):
        return {'terms': {self.field: self.value}} if self.value else {
            'terms': {'field': self.field, 'size': self.size}}


class Aggs:
    def __init__(self, names, nodes) -> None:
        self.names = names if isinstance(names, list) else [names]
        self.nodes = nodes if isinstance(nodes, list) else [nodes]

    def create_query(self):
        return {'aggs': {name: node.create_query()} for name, node in zip(self.names, self.nodes)}


class Should(WeighedNode):
    def __init__(self, nodes: List[WeighedNode], weight=100.0, do_normalize: bool = True):
        super().__init__(None, None, weight)
        self.do_normalize = do_normalize
        self.nodes = [node for node in nodes if node]

    def __bool__(self):
        return bool(self.nodes)

    def create_query(self):
        nodes = [node.create_query() for node in self.nodes]
        query = {"bool": {"should": nodes}}
        if self.do_normalize:
            query = {
                "function_score": {
                    "boost_mode": "multiply",
                    "boost": 1 / (sum(node.weight for node in self.nodes if node.weight) or 1) * self.weight,
                    "query": query
                }
            }
        return query

    def create_filter(self):
        return {'bool': {'should': [node.create_filter() for node in self.nodes]}}


class Must(FieldNode):
    def __init__(self, nodes: List):
        super().__init__(None, None)
        self.nodes = nodes

    def create_query(self):
        return {'bool': {'must': [node.create_query() for node in self.nodes]}}

    def create_filter(self):
        return {'bool': {'must': [node.create_filter() for node in self.nodes]}}


class DisMax(WeighedNode):
    def __init__(self, nodes: List):
        super().__init__(None, None)
        self.nodes = [node for node in nodes if node]

    def create_query(self):
        nodes = [node.create_query() for node in self.nodes if node]
        return {"dis_max": {"queries": nodes}} if len(nodes) > 1 else nodes[0]


class FunctionScore(WeighedNode):
    def __init__(self, node, weight=100, script_score=None):
        super().__init__(None, None, weight)
        self.node = node
        self.script_score = script_score

    def create_query(self):
        query = {
            "function_score": {
                "boost_mode": "multiply",
                "boost": self.weight,
                "query": self.node.create_query()
            }
        }
        if self.script_score:
            query["function_score"]["script_score"] = self.script_score

        return query
