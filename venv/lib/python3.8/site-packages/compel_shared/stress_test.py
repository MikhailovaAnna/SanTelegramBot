import argparse
import asyncio
import random
from abc import ABC, abstractmethod
from time import time

import aiohttp
from compel_shared import dict_subset
from compel_shared.logger import get_logger
from compel_shared.model import DB
from funcy import omit

log = get_logger(__name__)


class StressTest(ABC):
    def __init__(self, concurrency, timeout, number, url):
        self.concurrency = concurrency
        self.timeout = timeout
        self.number = number
        self.url = url

    async def run_all(self):
        raise Exception('not implemented')

    async def run(self, concurrency=None, timeout=None, size=None, number=None):
        concurrency = concurrency or self.concurrency
        timeout = timeout or self.timeout
        size = size or self.size
        number = number or self.number

        log.info('Start test')
        samples = await self.get_samples()
        if not samples:
            raise Exception('No samples collected')

        assert concurrency < number  # XXX иначе ничего не запустится сейчас, молча

        if size > len(samples):
            # random.sample() would fail otherwise
            log.warning(f'Decreasing random sample size to {len(samples)}')
            size = len(samples)

        async with aiohttp.ClientSession() as session:
            async def make_request():
                cut_samples = random.sample(samples, size)
                req = self.get_request(cut_samples)
                ts = time()
                try:
                    async with session.post(self.url,
                                            json=req,
                                            timeout=timeout) as resp:
                        if resp.status != 200:
                            text = await resp.text()
                            raise Exception(f'Failed - {resp.status} - {text}')
                        content = await resp.json()
                    ts = time() - ts
                    log.info(f'Call complete - duration={ts:.2f}')
                except Exception as e:
                    ts = time() - ts
                    log.error(f'Request failed after {ts:.2f} sec - {req} - {e}')
                    raise e

            async def run_thread():
                for i in range(number // concurrency):
                    await make_request()

            t = time()
            threads = [run_thread() for i in range(concurrency)]
            await asyncio.gather(*threads)
            t = time() - t
            lps = self.population / t
            rps = number / t
            log.info(f'{self.population} lines in {t:.2f} s, {lps:.1f} lines/sec, {rps:.1f} rps')
            return lps

    @staticmethod
    def add_args(cls, parser):
        parser.add_argument('-c', '--concurrency', type=int, help='Concurrency level', default=10)
        parser.add_argument('-t', '--timeout', type=int, help='Timeout, sec', default=600)
        parser.add_argument('-n', '--number', type=int, help='Number of requests', default=100)
        parser.add_argument('-a', '--all', help='Run with all parameters', action='store_true')

    @abstractmethod
    async def get_samples(self) -> list:
        pass

    @abstractmethod
    def get_request(self, samples) -> dict:
        pass


class StressTestMpns(StressTest, ABC):

    def __init__(self, size, concurrency, timeout, number, url):
        super().__init__(concurrency, timeout, number, url)
        self.size = size
        self.population = self.size * self.number

    async def run_all(self):
        lines = []
        for c in reversed([1, 10, 20, 50]):
            for s in reversed([10, 50, 100, 200, 500]):
                t = await self.run(c, self.timeout, s, max(c, self.number))
                lines.append(f'{s}, {c}, {t:.9f}')
        print('size, concurrency, rate')
        for line in lines:
            print(line)

    async def get_samples(self) -> list:
        db = DB()
        log.info(f'Getting {self.population} random mpns...',
                 concurrency=self.concurrency, size=self.size, number=self.number)

        mpns = await db.db.local_product.aggregate([
            {'$sample': {'size': self.population}},
            {'$project': {'mpn': 1, 'manufacturer': 1}}
        ]).to_list(None)

        mpns = [dict_subset(m, 'mpn', 'manufacturer') for m in mpns]
        return mpns

    @staticmethod
    def add_args(cls, parser):
        StressTest.add_args(cls, parser)
        parser.add_argument('-s', '--size', type=int, help='Request size', default=100)


def run_test(url: str, TestClass):
    parser = argparse.ArgumentParser(description='Run stress load')
    TestClass.add_args(TestClass, parser)
    args = parser.parse_args()
    log.info('Args', **vars(args))
    test_obj = TestClass(**omit(vars(args), {'all'}), url=url)  # type: StressTest
    fut = test_obj.run_all() if args.all else test_obj.run()
    asyncio.get_event_loop().run_until_complete(fut)
