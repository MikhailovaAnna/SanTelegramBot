import logging
from contextvars import ContextVar
from datetime import datetime
from decimal import Decimal

import structlog
from aiohttp import web

from compel_shared import short_uid
from compel_shared.config import env

_request_id = ContextVar('request_id')


def get_logger(name=None) -> structlog.stdlib.BoundLogger:
    return structlog.getLogger(name)


def _request_id_processor(logger, method_name, event_dict: dict):
    req_id = _request_id.get(None)
    if req_id:
        # мы можем достать валидный request_id из ContextVar в случае логгирования из обработчика запроса
        # в случае логгирования из access log достаём request_id из request (в другом месте)
        # перезатирать здесь значение нуллом нельзя
        event_dict['request_id'] = req_id
    return event_dict


def _move_non_standard_entries_processor(logger, method_name, event_dict: dict):
    # XXX есть специальный ключ '_record' - его нельзя перемещать
    #  возможно есть и другие такие опасные, так что на всякий случай игнорю все начинающиеся с "_"
    std_keys = {'@timestamp', 'event', 'level', 'logger', '_record',
                'body', 'method', 'url',
                'duration', 'query', 'remote', 'request_id'}
    non_std_dict = {}  # все нестандартные ключи будут перемещены сюда
    for key, val in event_dict.items():
        if key not in std_keys and not key.startswith('_'):
            non_std_dict[key] = event_dict[key]
    if non_std_dict:
        for key in non_std_dict.keys():
            del event_dict[key]
        event_dict['data'] = non_std_dict
    return event_dict


def init_logger(level=logging.INFO):
    env_level = env('LOGLEVEL', None)
    if env_level:
        env_level = logging._nameToLevel[env_level]
    level = env_level or level
    do_json = env('JSON_LOG', None)
    renderer = structlog.processors.JSONRenderer(ensure_ascii=False,
                                                 indent=None,
                                                 default=str,
                                                 sort_keys=True) if do_json else structlog.dev.ConsoleRenderer()

    processors = [
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso", key='@timestamp', utc=False),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
    ]

    if do_json:
        processors.append(_move_non_standard_entries_processor)
        processors.append(_request_id_processor)

    structlog.configure(
        processors=[structlog.stdlib.filter_by_level] + processors + [
            structlog.stdlib.ProcessorFormatter.wrap_for_formatter],
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
        cache_logger_on_first_use=True)

    formatter = structlog.stdlib.ProcessorFormatter(
        processor=renderer,
        foreign_pre_chain=processors)

    handler = logging.StreamHandler()
    handler.setFormatter(formatter)
    root_logger = logging.getLogger()
    root_logger.addHandler(handler)
    root_logger.setLevel(level)


@web.middleware
async def add_request_id_middleware(request, handler):
    """
    Создаёт и сохраняет request_id в разные места:
    - для логгирования изнутри обработчика запроса сохраняем в ContextVar
    - для логгирования изнутри access-log сохраняем на запросе
    Потому что к моменту вызова access-log ContextVar будет уже очищен
    """
    req_id = short_uid()
    token = _request_id.set(req_id)
    request.request_id = req_id
    try:
        return await handler(request)
    finally:
        _request_id.reset(token)  # release memory


if __name__ == '__main__':

    init_logger()

    # Emit a log!
    log = structlog.get_logger('STRUCT')
    log.info("Тест сообщение info - structlog", data1=Decimal(1), ts=datetime.now(), data2=dict(a='B'),
             data3=[1, 2, 3, 4])
    log.debug("Тест сообщение debug - structlog", data1=1, data2=dict(a='B'), data3=[1, 2, 3, 4])

    std_log = logging.getLogger('STD')
    std_log.info("Тест сообщение info - std")
    std_log.debug("Тест сообщение debug - std")

    try:
        raise Exception('test exc')
    except Exception as e:
        log.exception('struct error')
        std_log.exception('std error')
