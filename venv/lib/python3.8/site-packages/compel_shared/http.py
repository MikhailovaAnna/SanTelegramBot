import aiohttp
import asyncio
import time
from aiohttp import web
from functional import seq
from funcy import get_in, project
from typing import List

from compel_shared import json_dumps, dict_subset
from compel_shared.logger import get_logger

log = get_logger(__name__)

MAX_STR_LOG_LENGTH = 256
MAX_LIST_LOG_LENGTH = 10


def content_head(cont):
    if isinstance(cont, dict):
        cont = cont.copy()
        for k in list(cont)[:MAX_LIST_LOG_LENGTH]:
            cont[k] = content_head(cont[k])
        return cont
    if isinstance(cont, list):
        cont = cont.copy()
        return cont[:MAX_LIST_LOG_LENGTH]
    elif isinstance(cont, str) and len(cont) > MAX_STR_LOG_LENGTH:
        return cont[:MAX_STR_LOG_LENGTH] + '...'
    return cont


def raise_status(status, text, url):
    if status == 404:
        raise web.HTTPNotFound(text=text)
    else:
        raise Exception(f'Got {status} from call to {url} : {text}')


async def http_request(url, method_name, result_type, read_timeout=None, **kwargs):
    """
    Make single HTTP request
    :param url:
    :param method_name: either of get, post, put, delete
    :param result_type: either of text, json
    :param kwargs:
    :return:
    """
    async with aiohttp.ClientSession(json_serialize=json_dumps, read_timeout=read_timeout) as session:
        method = getattr(session, method_name)
        ts = time.time()
        try:
            async with method(url, **kwargs) as resp:
                log_info = dict(method=method_name, url=url, status=resp.status, **kwargs)
                if resp.status != 200:
                    text = await resp.text()
                    log.error('Call failed', response=text, **log_info)
                    raise_status(resp.status, text, url)
                method = getattr(resp, result_type)
                content = await method()
                log.info('Call complete', duration=time.time() - ts, **log_info)
                return content
        except asyncio.TimeoutError as e:
            log.exception(f'Call timed out after {read_timeout}s', read_timeout=read_timeout,
                          method=method_name,
                          url=url, **kwargs)
            raise web.HTTPServiceUnavailable()


async def http_get_json(url, **kwargs):
    return await http_request(url, 'get', 'json', **kwargs)


async def http_get_text(url, **kwargs):
    return await http_request(url, 'get', 'text', **kwargs)


async def http_post(url, **kwargs):
    return await http_request(url, 'post', 'text', **kwargs)


async def http_post_json(url, **kwargs):
    return await http_request(url, 'post', 'json', **kwargs)


async def http_put_json(url, **kwargs):
    return await http_request(url, 'put', 'json', **kwargs)


class HTTPRequest:

    def __init__(self, url, method='get', result_type='json', error_placeholder=None, **kwargs):
        self.url = url
        self.method = method
        self.result_type = result_type
        self.error_placeholder = error_placeholder
        self.kwargs = kwargs

    def __str__(self):
        return f'{self.method} {self.url} ({self.kwargs})'

    def to_dict(self):
        return dict(url=self.url, method=self.method, **self.kwargs)


async def http_batch(requests: List[HTTPRequest], batch_size, read_timeout=None):
    results = []

    ts = time.time()
    async with aiohttp.ClientSession(json_serialize=json_dumps, read_timeout=read_timeout) as session:
        for batch in seq(requests).grouped(batch_size):
            debug_info = []

            async def make_request(r: HTTPRequest):
                method = getattr(session, r.method)
                call_context = dict_subset(r.to_dict(), 'url', 'method')
                call_context.update(**r.kwargs)
                try:
                    async with method(r.url, **r.kwargs) as resp:

                        log_data = dict(status=resp.status, **call_context)

                        if resp.status != 200:
                            text = await resp.text()
                            log_data['response'] = text
                            if r.error_placeholder:
                                log.error('Call failed', **log_data)
                                debug_info.append(log_data)
                                return r.error_placeholder
                            log.error('Call failed', **log_data)
                            raise_status(resp.status, text, r.url)
                        method = getattr(resp, r.result_type)
                        content = await method()
                        debug_info.append(dict(**log_data))
                        return content
                except asyncio.TimeoutError as e:
                    log.exception(f'Call timed out after {read_timeout}s', read_timeout=read_timeout, **call_context)
                    if r.error_placeholder:
                        return r.error_placeholder
                    raise web.HTTPServiceUnavailable(text=f'Call timeout for {r.url}')
                except Exception as e:
                    log.exception('Call failed', **call_context)
                    if r.error_placeholder:
                        return r.error_placeholder
                    raise e

            requests = [make_request(r) for r in batch]
            results = results + await asyncio.gather(*requests)
            log.info(f'Completed {len(requests)} requests', batch=debug_info[:MAX_LIST_LOG_LENGTH],
                     duration=time.time() - ts)

    return results
