import typing
from dataclasses import field
from marshmallow.fields import Str, List, Nested
from marshmallow_dataclass import dataclass

from compel_shared import load_yml
from compel_shared.conf import ConfigElement, i18nNamed
from compel_shared.params.param import ParamRecog, ParamBase
from compel_shared.schema import (
    DictField,
    MongoIDSchema,
    OrderedSchema,
    MultilangField,
    Samples)


@dataclass(base_schema=OrderedSchema)
class NodePath:
    id: str = Str()
    name: str = Str(title='Название')


@dataclass(base_schema=OrderedSchema)
class ClassAnalytic(ConfigElement):
    product_count: int = field(metadata=dict(
        allow_none=True,
        title="Продуктов в классе",
        description="Количество продуктов привязанных к классу",
        readonly=True
    ))


@dataclass(base_schema=OrderedSchema)
class Tech(ConfigElement):
    m10: str = field(default=None,
                     metadata=dict(
                         enum_key='m10_tech',
                         title='m10',
                         description='Технологический тип для срочного производства модулей',
                         allow_none=True,
                         inheritable=True,
                     ))
    ems: str = field(default=None,
                     metadata=dict(
                         enum_key='ems_tech',
                         title='ems',
                         description='Технологический тип для контрактного производства',
                         allow_none=True,
                         inheritable=True,
                     ))


@dataclass(base_schema=OrderedSchema)
class ClassParamAnalytic:
    product_count: int = field(default=0, metadata=dict(
        title='Продуктов',
        description='Количество продуктов с параметром',
        readonly=True))
    samples: Samples = None


@dataclass(base_schema=OrderedSchema)
class ImportClassParamAnalytic(ClassParamAnalytic):
    samples: Samples = None


@dataclass(base_schema=OrderedSchema)
class ClassParam(ParamBase):
    required: bool = field(
        metadata=dict(
            title='Обязательный параметр',
            description='''
            Значение влияет на развесовку и фильтрацию параметров при поиске.
            Обязательные параметры ищутся с особым весом, а также их полный набор 
            может быть обязательным при поиске продуктов.
            '''
        ),
        default=False)

    displayed: bool = field(
        metadata=dict(
            title='Показывать в API',
            description='Если не отмечено, параметр не будет показываться в каталоге в контексте этого класса'
        ),
        default=True)

    # todo возможно, класс ClassParamAnalytic не нужен и стоит просто использовать ParamAnalytic
    #  + вынести его в ParamBase
    analytic: ClassParamAnalytic = field(
        default=None,
        metadata=dict(
            title="Аналитика данных",
            unwrap=True,
            readonly=True
        ))

    order: int = field(
        default=None,
        metadata=dict(
            allow_none=True,
            title='Порядок отображения',
            description='Порядок отображения параметра при отображении в catalog/api/params',
            unique=True
        )
    )


@dataclass(base_schema=OrderedSchema)
class ImportClassParam:
    analytic: ImportClassParamAnalytic = field(default=None, metadata=dict(
        title="Аналитика данных",
        unwrap=True,
        readonly=True))
    recog: ParamRecog = field(default=None, metadata=dict(
        title='Конфигурация распознавания', unwrap=True))
    target_id: str = field(default=None, metadata=dict(
        title='Параметр назначения',
        enum_key='target_params',
        as_tree_enum=True,
        description='''
        Параметр назначения куда будут складываться значения выделенные из данного параметра.
        
        Код параметра назначения автоматически добавляется ко всем макросам (`$N`, `$S` и т.д.) используемым в шаблонах.
        Если параметр назначения не указан, то коды параметров назначения должны быть прописаны в шаблонах полностью -
        например `$N_temperature_min`.
        '''
    ))


@dataclass(base_schema=MongoIDSchema)
class Class(i18nNamed):
    id: str = field(
        default=None,
        metadata=dict(
            data_key='_id',
            title='Уникальный ID',
            is_hidden=True)
    )

    code: str = field(
        default=None,
        metadata=dict(
            allow_none=True,
            title='Код',
            description='Используется при формировании сигнатуры продуктов',
            unique=True)
    )
    legacy_id: int = field(
        default=None,
        metadata=dict(
            allow_none=True, title='Цифровой идентификатор класса', description='Цифровой идентификатор класса')
    )
    name: typing.Dict[str, str] = field(
        default_factory=dict,
        metadata=dict(
            marshmallow_field=MultilangField(
                title='Название',
                description='Локализоанное название класса в каталоге',
                required_on_create=True, ))
    )

    parent_id: str = field(
        default=None, metadata=dict(
            title='Родительский класс',
            allow_none=True,
            as_tree_enum=True,
            enum_key='class_tree_wo_current',
            is_hidden=True, )
    )

    axapta_id: str = field(
        default=None, metadata=dict(
            title='Axapta ID',
            description='Код раздела в Axapta',
            example='0403020101',
            is_hidden=True
        )
    )
    axapta_name: str = field(default=None, metadata=dict(
        title='axapta_name',
        description='Имя класса в Axapta',
        example='Конденсаторы керамические',
        is_hidden=True
    ))
    recognized: bool = field(
        default=False,
        metadata=dict(
            default=False,
            title='Распознается',
            description='Если не отмечено, параметры данного класса не будут использоваться при поиске продуктов')
    )

    is_leaf: bool = field(
        default=False
    )

    providers: typing.List[str] = field(
        default=None,
        metadata=dict(marshmallow_field=List(
            Str(enum_key='providers'),
            title='Приоритет источников',
            description='Список провайдеров, у которых берется класс, в порядке приоритета',
            allow_none=True,
            inheritable=True, ))
    )

    analytic: ClassAnalytic = field(
        default=None,
        metadata=dict(
            title="Аналитика данных",
            allow_none=True,
            unwrap=True,
            readonly=True, )
    )

    tech: Tech = field(default=None, metadata=dict(
        title='Технологические типы',
        description='Технологические типы для срочного (m10) и контрактного (ems) производства модулей',
        example=dict(m10='CERCAP'),
        allow_none=True,
        unwrap=True,
        inheritable=True,
    ))

    params: typing.Dict[str, ClassParam] = field(
        default_factory=dict,
        metadata=dict(
            marshmallow_field=DictField(
                Nested(ClassParam.Schema),
                allow_none=True,
                title='Параметры класса',
                modifiable=True, ))
    )

    @staticmethod
    def load_defaults():
        data = load_yml(__file__, 'classes.yml')
        for k in data:
            data[k]['code'] = k
        return data


@dataclass(base_schema=OrderedSchema)
class ClassImportAnalytic:
    product_count: int = field(metadata=dict(
        allow_none=True,
        title="Кол-во продуктов, привязанных к классу",
        readonly=True,
    ))
    product_count_no_children: int = field(
        default=None,
        metadata=dict(
            allow_none=True,
            title="Кол-во продуктов, привязанных к классу без учета вложенности",
            readonly=True,
        )
    )
    product_samples: typing.List[str] = field(
        default_factory=list, metadata=dict(is_hidden=True))


@dataclass
class Candidate:
    id: str
    product_count: int


@dataclass(base_schema=MongoIDSchema)
class ClassImport:

    id: str = field(
        metadata=dict(
            data_key='_id',
            title='Уникальный ID',
            is_hidden=True)
    )

    path: typing.List[NodePath] = field(
        default=None,
        metadata=dict(
            title='Путь в каталоге источника',
            is_hidden=True)
    )

    parent_id: str = field(
        default=None,
        metadata=dict(
            title='ID родительского класса',
            allow_none=True,
            is_hidden=True
        )
    )
    code: str = field(
        default=None,
        metadata=dict(
            allow_none=True, title='Код', description='Код класса', unique=True)
    )
    name: str = field(default=None, metadata=dict(
        title='Имя класса источника',
        description='Имя класса источника',
        example='USB Adapters',
        is_hidden=True
    ))
    provider: str = field(default=None, metadata=dict(
        title='Имя источника класса',
        description='Откуда пришел данный класс',
        example='farnell',
        required_on_create=True
    ))
    target_id: str = field(default=None, metadata=dict(
            title='Класс назначения',
            description='Класс к которому привязываются продукты из данного класса источника',
            as_tree_enum=True,
            enum_key='class_tree_with_candidates', )
    )

    is_bound: bool = field(
        default=False,
        metadata=dict(
            is_hidden=True)
    )

    candidates: typing.List[Candidate] = field(
        default_factory=list,
        metadata=dict(
            is_hidden=True)
    )

    params: typing.Dict[str, ImportClassParam] = field(
        default_factory=dict,
        metadata=dict(marshmallow_field=DictField(
            Nested(ImportClassParam.Schema),
            allow_none=True,
            title='Параметры класса',
        ))
    )
    # TODO: obsolete
    param_filter: typing.List[str] = field(
        default=None,
        metadata=dict(
            title='Допустимые параметры для класса',
            missing=None,
            is_hidden=True)
    )

    analytic: ClassImportAnalytic = field(
        default=None,
        metadata=dict(
            title="Аналитика данных",
            allow_none=True,
            unwrap=True,
            readonly=True, )
    )
