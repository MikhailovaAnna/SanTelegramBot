import typing
from functools import wraps

from compel_shared import first_float
from compel_shared.params import convert_value


def _get_handler(f, pick_value):
    @wraps(f)
    def handler(value) -> str:
        if value is not None:
            if value and isinstance(value, list):
                value = pick_value(value)
            return f(value)
        else:
            return ""

    return handler


def with_first_value(f):
    def pick_value(value):
        return value[0]

    handler = _get_handler(f, pick_value)
    return handler


def with_max_value(f):
    def pick_value(value):
        return max(value)

    handler = _get_handler(f, pick_value)
    return handler


def with_min_value(f):
    def pick_value(value):
        return min(value)

    handler = _get_handler(f, pick_value)
    return handler


def _format_float(value, precision=3):
    if isinstance(value, list):
        value = value[0]
    result = f"{value:.{precision}f}" if not isinstance(value, str) else value
    result = result.rstrip('0').rstrip('.')
    return result or "0"


def _format_float_scalar(value: float, precision: int = 3) -> str:
    res = f"{value:.{precision}f}" if precision == 0 else f"{value:.{precision}f}".rstrip('0').rstrip('.')
    return res or "0"


@with_first_value
def string_value(value) -> str:
    return value


@with_max_value
def temperature_max(value) -> str:
    return f"{value:.0f}C"


def temperature(params) -> str:
    temperature_min = params.get('temperature$min')
    temperature_max = params.get('temperature$max')
    temperature = params.get('temperature')
    if temperature:
        return f"{temperature:.0f}C"
    elif temperature_min and temperature_max:
        return f"{temperature_min}/+{temperature_max}C"


@with_min_value
def lifetime(value) -> str:
    return f"{int(value)}H"


@with_first_value
def ppm(value) -> str:
    return f"{int(value)}ppm"


@with_first_value
def current(value) -> str:
    if value < 1e-3:
        return f"{_format_float(value * 1e6)}UA"
    else:
        return f"{_format_float(value)}A"


def filmcap_voltage(params: typing.Dict) -> str:
    result = []
    voltage_ac = params.get('voltage$ac')
    voltage_dc = params.get('voltage$dc')
    voltage = params.get('voltage')
    if voltage_ac and voltage_dc:
        voltage_ac_float = first_float(voltage_ac)
        voltage_dc_float = first_float(voltage_dc)
        if voltage_ac_float and voltage_dc_float:
            if voltage_ac_float > 0:
                result.append(f'{_format_float_scalar(voltage_ac_float)}VAC')
            if voltage_dc_float > 0:
                result.append(f'{_format_float_scalar(voltage_dc_float)}VDC')
    elif voltage:
        voltage = first_float(voltage)
        if voltage > 0:
            result.append(f'{voltage}V')
    return " ".join(result)


def filmcap_dimension(params: typing.Dict) -> str:
    result = ""
    length = params.get('dimension$length')
    height = params.get('dimension$height')
    width = params.get('dimension$width')
    if length and height and width:
        length_float = first_float(length)
        height_float = first_float(height)
        width_float = first_float(width)
        if length_float and height_float and width_float:
            result += f"{_format_float_scalar(length_float * 1000)}X" \
                      f"{_format_float_scalar(width_float * 1000)}X" \
                      f"{_format_float_scalar(height_float * 1000)}"
    return result


def ecap_dimension(params) -> str:
    diameter = params.get('dimension$diameter')
    height = params.get('dimension$height')
    if diameter and height:
        diameter_float = first_float(diameter)
        height_float = first_float(height)
        if diameter_float and height_float:
            return f"{_format_float_scalar(diameter_float * 1000, 1)}X{_format_float_scalar(height_float * 1000, 1)}"
    return ""


def dimension_pitch(value) -> str:
    if value is not None:
        value_float = first_float(value)
        if value_float and value_float > 0:
            return f"P{_format_float_scalar(value_float * 1000)}"
    return ""


def res_case(params: typing.Dict) -> str:
    # если монтаж (mount) SMD, отображаем код корпуса (case); если другой - отображаем монтаж и мощность (power)
    mount = params.get('mount') or ''
    power = params.get('power') or ''
    case = params.get('case') or ''
    if str(mount).lower() == 'smd':
        result = case
    else:
        power = first_float(power)
        power = f'{_format_float_scalar(power)}W' if power else ''
        result = [param for param in [case, power] if param]
        result = ' '.join(result)
    return result


class Signature:

    def __init__(self, params_config: typing.Dict):
        self.params_config = params_config
        self.signatures_map: typing.Dict[str, typing.Callable] = {
            'RES': self._res,
            'CERCAP': self._cercap,
            'ECAP': self._ecap,
            'FERRITE': self._ferrite,
            'FILMCAP': self._filmcap,
            'IND': self._ind,
            'TECAP': self._tecap,
            'XTAL': self._xtal,
            'XO': self._xo
        }

    def render_parameter(self, params: typing.Dict, pname: str) -> str:
        param_config = self.params_config.get(pname, None)
        if param_config and pname in params:
            value = params.get(pname)

            if value is None:
                return ''
            if isinstance(value, str):
                return value

            if param_config.recog and param_config.recog.alt_formats:
                alt_f = param_config.recog.alt_formats[0]
                if type(value) == list:
                    return convert_value([alt_f.to_text(e) for e in value])
                elif isinstance(value, dict):
                    return convert_value([alt_f.to_text(e) for e in value.values()])
                else:
                    return alt_f.to_text(value)
            else:
                return convert_value(params.get(pname))

    @staticmethod
    def _join_signature(signatures: typing.List) -> str:
        sig_out = []
        for signature in signatures:
            if signature:
                sig_out.append(signature)
        return ' '.join(sig_out)

    @staticmethod
    def _get_signature(parts):
        signatures = []
        for func, *args in parts:
            try:
                signatures.append(func(*args))
            except:
                pass
        return signatures

    def _res(self, params: typing.Dict) -> str:
        parts = [(res_case, params),
                 (self.render_parameter, params, 'resistance'),
                 (self.render_parameter, params, 'tolerance')]
        return self._join_signature(self._get_signature(parts))

    def _cercap(self, params: typing.Dict) -> str:
        parts = [(string_value, params.get('case')),
                 (self.render_parameter, params, 'capacitance'),
                 (self.render_parameter, params, 'voltage'),
                 (string_value, params.get('dielectric')),
                 (self.render_parameter, params, 'tolerance')]
        return self._join_signature(self._get_signature(parts))

    def _ecap(self, params: typing.Dict) -> str:
        parts = [(string_value, params.get('mount')),
                 (self.render_parameter, params, 'capacitance'),
                 (self.render_parameter, params, 'voltage'),
                 (temperature_max, params.get('temperature$max')),
                 (lifetime, params.get('life')),
                 (ecap_dimension, params)]
        return self._join_signature(self._get_signature(parts))

    def _ferrite(self, params: typing.Dict) -> str:
        parts = [(string_value, params.get('case')),
                 (self.render_parameter, params, 'impedance'),
                 (current, params.get('current'))]
        return self._join_signature(self._get_signature(parts))

    def _filmcap(self, params: typing.Dict) -> str:
        parts = [(self.render_parameter, params, 'capacitance'),
                 (filmcap_voltage, params),
                 (string_value, params.get('class')),
                 (filmcap_dimension, params),
                 (dimension_pitch, params.get('dimension$pitch'))]
        return self._join_signature(self._get_signature(parts))

    def _ind(self, params: typing.Dict) -> str:
        parts = [(string_value, params.get('case')),
                 (self.render_parameter, params, 'inductance'),
                 (current, params.get('current')),
                 (self.render_parameter, params, 'tolerance')]
        return self._join_signature(self._get_signature(parts))

    def _tecap(self, params: typing.Dict) -> str:
        parts = [(self.render_parameter, params, 'capacitance'),
                 (self.render_parameter, params, 'voltage'),
                 (string_value, params.get('case$tantal')),
                 (self.render_parameter, params, 'tolerance')]
        return self._join_signature(self._get_signature(parts))

    def _xtal(self, params: typing.Dict) -> str:
        parts = [(string_value, params.get('series')),
                 (self.render_parameter, params, 'frequency'),
                 (ppm, params.get('ppm$25')),
                 (self.render_parameter, params, 'capacitance$load'),
                 (temperature, params)]
        return self._join_signature(self._get_signature(parts))

    def _xo(self, params: typing.Dict) -> str:
        parts = [(string_value, params.get('series')),
                 (self.render_parameter, params, 'frequency'),
                 (ppm, params.get('ppm')),
                 (self.render_parameter, params, 'voltage'),
                 (temperature, params)]
        return self._join_signature(self._get_signature(parts))

    def get_for(self, class_code: str, params_values: typing.Dict) -> str:
        """
        Возвращает сигнатуру для указанного класса и значений параметров
        :param class_code: код класса
        :param params_values: значения параметров в виде {<код>: <значение>, ...}
        :return: сигнатура в виде строки
        """
        if class_code in self.signatures_map and self.signatures_map[class_code]:
            return self.signatures_map[class_code](params_values)
        return ''

    def classes(self) -> typing.List[str]:
        return list(self.signatures_map.keys())
