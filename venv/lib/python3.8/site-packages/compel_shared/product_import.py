from funcy import compact

from compel_shared import dict_subset, to_int_or_float
from compel_shared.conf.product_config import ProductsConfig
from compel_shared.logger import get_logger
from compel_shared.model import normalize_name, create_update_one
from compel_shared.xls_utils import from_xlsio_generator

log = get_logger(__file__)


PRODUCT_IMPORT_FIELDS = ['axapta_class_id', 'case', 'manufacturer', 'mpn', 'names', 'descriptions.ru',
                         'descriptions.en']


async def mpn_substitute(sc, mpn):
    if mpn:
        products = await sc.get_section('products')  # type: ProductsConfig
        for replacement in products.mpn_replacement:
            mpn = mpn.replace(replacement.find, replacement.replace)
    return mpn


async def import_products(db, sc, source_file, import_fields):
    chunk_size = 1000
    updates = []
    loaded = 0

    data_generator = from_xlsio_generator(source_file)
    header = next(data_generator)
    params_to_import = [x for x in header if x.startswith('params.')]
    import_fields.extend(params_to_import)
    classes_map = await _get_classes_map(db)

    for item in data_generator:
        mpn = await mpn_substitute(sc, item.pop('mpn'))
        man = item.pop('manufacturer', '') or ''
        query = {'mpn': mpn, 'manufacturer': man}
        if mpn:
            _prepare_import_item(item)
            _transform_param_types(item, params_to_import)
            item = compact(dict_subset(item, *import_fields))
            if item:
                _resolve_class(item, classes_map)
                doc_to_update = {f'data.compel-admin.{k}': v for k, v in item.items()}
                doc_to_update.update(dirty=True)
                class_id = item.get('class_id')
                add_to_set = {'class_id': class_id} if class_id else None
                updates.append((query, doc_to_update, add_to_set))

        if len(updates) >= chunk_size:
            loaded += await _update_products(db, updates)
            updates = []

    if updates:
        loaded += await _update_products(db, updates)
    return loaded


def _prepare_import_item(item):
    """
    Операция обратная той, что делается при экспорте
    """
    for k, v in item.items():
        if k.startswith('params'):
            if isinstance(v, str) and '\n' in v:
                item[k] = v.split('\n')

        if k == 'names' and v:
            item['names'] = [{
                'value': v,
                'value_norm': normalize_name(v),
                'source_type': 'compel-admin'
            }]


def _transform_param_types(item, params_to_import):
    """
    Trying to change param's type to int or float if possible
    """
    str_params = ['application', 'aux', 'case', 'case$tantal', 'class', 'color', 'config', 'converter', 'core',
                  'dielectric', 'features', 'frequence$type', 'interface', 'mem$type', 'mount', 'mount$mount',
                  'out', 'protection', 'series', 'subtype', 'type', 'voltage$type']
    str_param_names = [f'params.{x}' for x in str_params]

    for param in [x for x in params_to_import if x not in str_param_names]:
        if item[param]:
            item[param] = to_int_or_float(item[param])


async def _update_products(db, updates):
    bulk_updates = [create_update_one(q, u, add_to_set=a, upsert=True) for (q, u, a) in updates]
    res = await db.external_product.bulk_write(bulk_updates)
    loaded = res.matched_count + res.upserted_count
    return loaded


def _resolve_class(item, classes_map):
    """
    Resolve class, class_id for given axapta_class_id
    """
    axapta_class_id = item.get('axapta_class_id')
    if axapta_class_id:
        item['class_id'] = classes_map.get(axapta_class_id)[1]
        cls = classes_map.get(axapta_class_id)[0]
        if cls:
            item['class'] = classes_map.get(axapta_class_id)[0]


async def _get_classes_map(db):
    classes_map = {}
    async for cls in db.classes.find({'axapta_id': {'$exists': True}},
                                     {'_id': 1, 'axapta_id': 1, 'code': 1}):
        class_id = cls.get('_id')
        class_code = cls.get('code')
        classes_map[cls['axapta_id']] = (class_code, class_id)

    return classes_map
