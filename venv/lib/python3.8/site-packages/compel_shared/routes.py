from aiohttp import web
from aiohttp.web import Response
from functional import seq
from prometheus_client import REGISTRY
from prometheus_client import generate_latest, CollectorRegistry, CONTENT_TYPE_LATEST
from prometheus_client import multiprocess

import versioneer
from compel_shared import __version__
from compel_shared.config import LIVENESS_TEST, VERSION_PATH, METRICS_PATH, \
    PERFORMANCE_PATH, DOCS_PATH, PROMETHEUS_MULTIPROC_DIR, PROMETHEUS_MULTIPROC_PATH, HOME_PATH


def redirect_root_to_docs(routes):
    @routes.get(HOME_PATH)
    async def get(self):
        raise web.HTTPFound(DOCS_PATH)


def define_standard_views(routes):
    @routes.get(LIVENESS_TEST)
    async def get(request):
        return web.Response(text='Service is alive')

    @routes.get(VERSION_PATH)
    async def get(request):
        version_response = f'Component version: {versioneer.get_version()} \nShared version: {__version__}'
        return web.Response(text=version_response)

    @routes.get(METRICS_PATH)
    def metrics(request):
        if not PROMETHEUS_MULTIPROC_PATH:
            return Response(text=f'Prometheus is not configured with {PROMETHEUS_MULTIPROC_DIR}')

        registry = CollectorRegistry()
        multiprocess.MultiProcessCollector(registry)
        data = generate_latest(registry)
        resp = Response(body=data)
        resp.content_type = CONTENT_TYPE_LATEST
        return resp

    @routes.get(PERFORMANCE_PATH)
    async def get(self):
        def format(arr):
            arr = [str(arr[0]).ljust(64)] + [str(e).ljust(24) for e in arr[1:]]
            return ' '.join(arr)

        header = [format(['metric', 'sum', 'count', 'mean'])]
        out = {}
        for metric in REGISTRY.collect():
            if metric.type in ['histogram', 'summary']:
                for s in metric.samples:
                    name = metric.name
                    if s.labels:
                        name = name + '_' + "_".join(s.labels.values())
                    if not name in out:
                        out[name] = {}
                    if s.name.endswith('count'):
                        out[name]['cnt'] = s.value
                    elif s.name.endswith('sum'):
                        out[name]['sum'] = s.value

        out = [[k, out[k]['sum'], out[k]['cnt'], out[k]['sum'] / out[k]['cnt']] for k in out if
               'cnt' in out[k] and out[k]['cnt'] > 0]
        if out:
            out = seq(out).sorted(lambda l: l[-1], True).map(format).list()
        return web.Response(text='\n'.join(header + out))


def get_limit(request, default=100):
    limit = request.query.get('limit', default)
    try:
        limit = int(limit)
    except Exception as e:
        limit = default
    if limit < 1:
        limit = 1
    return limit


PARAM_FILTER_DOC = f'''
В качестве фильтра по каждому из полей может указываться:
* одно значение
* несколько значений (список)
* структура с операторами сравнения 

Если передается список значений то результаты фильтруются по совпадению любого из них.
Например, чтобы получить набор продуктов с заведомо известными ID можно отправить запрос вида:

    {{ "id" : ["YspbdJ98N5", "YspbdJ98N6", "YspbdJ98N7"] }}  

Возможен поиск продуктов, заданных парами `mpn` + `manufacturer`; такие пары передаются в списке `products`:

    {{ "products" : [
        {{ "mpn": "3296X-1-101", "manufacturer": "VAT" }},
        {{ "mpn": "AC0603JR-0715RL", "manufacturer": "YAG"}}
    ] }}

Для фильтрации по значениям параметров могут использоваться операторы:    
* $lt (<)
* $gt (>)
* $lte (<=)
* $gte (>=)
* $ne (!=)

Например, чтобы найти все продукты с tolerance < 5% нужно передать запрос вида:

    {{ "params" : {{ "tolerance" : {{ "$lt" : 5 }} }} }}

а для указания дипазона ширины 10-15 мм:

    {{ "params" : {{ "dimension" : {{ "width" : {{ "$gt" : 0.010, "$lt" : 0.015 }} }} }} }}

Если оператор не указан, то по умолчанию используется range/mode из соответствующей конфигурации параметра (за исключением gauss). 

Операторы сравнения могут использоваться только для параметров типа `measurement`
'''
