import typing
from typing import Dict

from compel_shared import flatten_dict
from compel_shared.params.params_handler import ParamsHandler
from compel_shared.schema import PagingRequestSchema

MAX_LIMIT = 1000


class PagingHandler:
    paging_request_schema = PagingRequestSchema()

    def _get_paging_value(self, data: typing.Dict, field_name):
        default = self.paging_request_schema.fields[field_name].default
        value = data.pop(field_name, default)
        try:
            value = int(value)
        except Exception as e:
            value = default
        return value

    def _get_limit(self, data):
        return max(0, self._get_paging_value(data, 'limit'))

    def _get_offset(self, data):
        return max(0, self._get_paging_value(data, 'offset'))


class MongoPagingHandler(PagingHandler):

    def __init__(self, collection):
        self.collection = collection

    async def _search(self, req_query, match_query, sort):
        limit = self._get_limit(req_query)
        offset = self._get_offset(req_query)
        count = await self.collection.count_documents(match_query)
        cursor = self.collection.find(match_query)
        if sort:
            cursor = cursor.sort(sort)
        if offset > 0:
            cursor = cursor.skip(offset)
        limit = min(limit, MAX_LIMIT) or MAX_LIMIT
        cursor = cursor.limit(limit)
        items = await cursor.to_list(limit)
        return dict(total=count, limit=limit, offset=offset, items=items)


class ProductHandler(MongoPagingHandler):

    def __init__(self, collection, ph: ParamsHandler):
        super().__init__(collection)
        self.ph = ph

    def process_sort_query(self, sort_query):
        res = flatten_dict(sort_query, '.')
        return res

    async def search(self, query: Dict, sort: Dict = {}):
        match_query = self._match_query_factory(query)
        if 'sort' in query:
            sort = self.process_sort_query(query['sort'])
        result = await self._search(query, match_query, sort)
        result['products'] = [await self._get_info(p) for p in result.pop('items')]
        return result

    async def _get_info(self, product):
        product['id'] = product.pop('_id')
        return await self.ph.product_option(product, details=True)

    def _get_expr(self, val):
        if isinstance(val, list):
            return {'$in': val}
        elif isinstance(val, dict):
            expr = {}
            for op in val:
                expr[f'${op}'] = val
            return expr
        return val

    def _match_query_factory(self, query: Dict):
        match_query = {}
        for key in query:
            self._handle_match_key(key, query, match_query)
        return match_query

    def _handle_match_key(self, key, query, match_query):
        """
        Handle single key from query.
        Override in subclass to implement special handling for specific key(s).
        @param key:
        @param query:
        @param match_query:
        """
        val = query[key]
        if key == 'id':
            key = '_id'
        if key == 'params':
            params_match_query = {}
            for subkey in val:
                self._handle_match_key(subkey, val, params_match_query)
                match_query[f'{key}.{subkey}'] = params_match_query[subkey]
        else:
            match_query[key] = self._get_expr(val)
