import os
import zipfile

from minio import Minio
from minio.error import NoSuchKey

from compel_shared.logger import get_logger
from .config import MINIO_URL, MINIO_BUCKET, MINIO_ACCESS_KEY, MINIO_SECRET_KEY

log = get_logger(__name__)


class MinioClient:

    def __init__(self, endpoint=MINIO_URL,
                 bucket: str = MINIO_BUCKET,
                 access_key=MINIO_ACCESS_KEY,
                 secret_key=MINIO_SECRET_KEY,
                 secure=False):
        if not access_key:
            raise Exception("MINIO_ACCESS_KEY not set")
        if not secret_key:
            raise Exception("MINIO_SECRET_KEY not set")

        def try_read_from_file(key):
            if os.path.exists(key) and os.path.isfile(key):
                with open(key) as f:
                    return f.read().strip()
            return key

        access_key = try_read_from_file(access_key)
        secret_key = try_read_from_file(secret_key)

        self.client = Minio(endpoint=endpoint,
                            access_key=access_key,
                            secret_key=secret_key,
                            secure=secure)
        self.bucket = bucket

    def upload(self, local_path, minio_path, zip=True, **kwargs):
        """
        Upload single file or all files from local_path to minio_path
        @param local_path:
        @param minio_path:
        @param kwargs:
        """

        def upload_file(file_path):
            out_name = os.path.join(minio_path, os.path.basename(file_path))
            in_name = file_path
            if zip:
                out_name = f'{out_name}.zip'
                in_name = f'{file_path}.zip'
                with zipfile.ZipFile(in_name, 'w', compression=zipfile.ZIP_DEFLATED) as z:
                    z.write(file_path, os.path.basename(file_path))

            self.client.fput_object(self.bucket, out_name, in_name, **kwargs)
            log.info(f'Uploaded {self.bucket}/{out_name}')
            if zip:
                os.remove(in_name)

        log.info(f'upload {local_path} to {minio_path}')
        if os.path.isdir(local_path):
            for folder_name, subfolders, filenames in os.walk(local_path):
                for filename in filenames:
                    upload_file(os.path.join(folder_name, filename))
        else:
            upload_file(local_path)

    def list_dir(self, minio_path, recursive=False):
        log.info(f'list_dir {minio_path}')
        return self.client.list_objects_v2(self.bucket, prefix=minio_path, recursive=recursive)

    def file_exists(self, minio_path):
        try:
            log.info(f'file_exists {minio_path}')
            self.client.stat_object(self.bucket, minio_path)
            return True
        except NoSuchKey as e:
            return False

    def download_dir(self, minio_path, local_path, unzip=True, **kwargs):
        """
        Download files from  minio_path to local_path and extract them if they zipped.
        @param minio_path:
        @param local_path:
        @param kwargs:
        """
        log.info(f'download_dir {minio_path}')
        for file in self.list_dir(minio_path):
            self.download_file(file.object_name, local_path, unzip, **kwargs)

    def download_file(self, minio_path, local_path, unzip=True, **kwargs):
        log.info(f'download_file {minio_path} to {local_path}')
        local_file = os.path.join(local_path, os.path.basename(minio_path))
        self.client.fget_object(self.bucket, minio_path, local_file, **kwargs)
        log.info(f'Downloaded {minio_path}')
        if minio_path.endswith('.zip') and unzip:
            with zipfile.ZipFile(local_file, 'r') as zip:
                zip.extractall(local_path)
                log.info(f'Extracted to {local_path}')
            os.remove(local_file)

    def remove(self, minio_path):
        log.info(f'remove {minio_path}')
        for file in self.client.list_objects_v2(self.bucket, prefix=minio_path, recursive=True):
            self.client.remove_object(self.bucket, file.object_name)
            log.info(f'Removed {minio_path}')
