from typing import List

from dataclasses import field
from marshmallow import fields
from marshmallow_dataclass import dataclass

from compel_shared.conf import ConfigElement
from compel_shared.schema import (
    OrderedSchema, PercentField, Weight, Fuziness)


@dataclass(base_schema=OrderedSchema)
class SearchConfigElement(ConfigElement):
    weight: Weight


@dataclass(base_schema=OrderedSchema)
class RegexpSearchConfig(SearchConfigElement):
    prefix_length: int = field(default=2, metadata=dict(
        title='Пропусков',
        description='Максимальное количество символов которое можно пропускать от начала при сравнении строк.',
        schema={'type': 'integer', 'minimum': 0, 'required': True},
    ))

    special_symbols: str = field(default='', metadata=dict(marshmallow_field=fields.Str(
        title='Спецсимволы',
        description='''
Перечисленные символы игнорируются при сравненнии строк во время поиска.
Например, если в списке присутсвует символ `*`,' то для строки `A$BC*DE.F` будут найдены варианты:'
'`A$BC2DE.F`, `A$BCKDE.F`, `A$BCтDE.F` и т.п.
''',
        allow_none=True,
    )))


@dataclass(base_schema=OrderedSchema)
class FuzzySearchConfig(RegexpSearchConfig):
    fuzziness: Fuziness = None
    prefix_length: int = field(default=None, metadata=dict(
        title='Макс. пропусков',
        description='Значение указывает сколько символов можно пропускать от начала при нечетком сравнении строк.',
        schema={'minimum': 0},
    ))


@dataclass(base_schema=OrderedSchema)
class RequiredParamSearchConfig(SearchConfigElement):
    any_of: List[str] = field(metadata=dict(
        title='Обязательные параметры',
        description='Если указан непустой список, то требуется наличие хотябы одного из перечисленных',
        enum_key='any_of'
    ))
    all_of_class: bool = field(
        default=False,
        metadata=dict(
            title='Все параметры обязательны',
            description='Если отмечено, то для поиска требуется наличие всех обязательных параметров в классе',
        )
    )


@dataclass(base_schema=OrderedSchema)
class DecaySearchConfig(ConfigElement):
    offset: int = field(metadata=dict(
        title='Смещение',
        schema={'type': 'integer', 'minimum': 0, 'maximum': 100},
        default=50,
        description='''
Допустимая разница в длине MPN (в %) от длины самого длинного MPN в поисковой строке.
В общем случае, если найдены несколько, MPN с большей длиной будет иметь более высокую релевантность.
При разнице длин MPN больше заданного offset, релевантность понижается в зависимости от разницы длин между искомым и самым длинным MPN.
* 0% означает что разница в длине всегда влияет на релевантность;
* 100% означает что разница в длине между несколькими MPN не влияет на релевантность.
Например, если существуют MPN `ASDFGHJK` и `ZXCV`, при offset = 50% оба MPN будут найдены с релевантностью 100%.
Для `ASDFGHJK` и `ZXCV` с offset = 25% более длинный MPN будет иметь релевантность 100%, более короткий - 50%.
''',
    ))
    scale: int = field(metadata=dict(
        title='Затухание',
        schema={'type': 'integer', 'minimum': 1, 'maximum': 100},
        default=100,
        description='''
Коэффициент затухания, на который домножается релевантность, если разница длин MPN ходит за offset.
Например, для MPN `ASDFGHJK` и `ZXCV`, при offset = 25% и scale = 100
более длинный MPN будет найден с релевантностью 100%, более короткий - 50%.
Для тех же самых MPN при offset = 25% и scale = 50% более длинный найдется с релевантностью 100%, более короткий - с 25%.
''',
    ))


@dataclass(base_schema=OrderedSchema)
class MpnSearchConfig:
    fuzzy: FuzzySearchConfig = field(metadata=dict(
        title='Нечеткость',
        description='Поиск по нечеткому совпадению с перестановкой символов'
    ))
    regexp: RegexpSearchConfig = field(metadata=dict(
        title='Подстрока',
        desription='Поиск по совпадению части строки через regexp'
    ))
    decay: DecaySearchConfig = field(
        metadata=dict(title='Поиск по нескольким MPN'))
    weight: Weight = 100


@dataclass(base_schema=OrderedSchema)
class DefaultTemplates:
    string: List[str]
    measurement: List[str]


@dataclass(base_schema=OrderedSchema)
class ParamsSearchConfig(SearchConfigElement):
    required: RequiredParamSearchConfig = field(
        metadata=dict(title='Обязательные'))
    optional: SearchConfigElement = field(metadata=dict(title='Необязательные'))
    fuzziness: Fuziness = 'AUTO'
    default_weight: int = field(default=100,
                                metadata=dict(marshmallow_field=PercentField(title='Вес',
                                                                             description='Вес параметра по умолчанию')))
    # TODO: remove
    default_templates: DefaultTemplates = field(default=None, metadata=dict(
        title='Стандартные шаблоны',
        allow_none=True,
        unwrap=True,
    ))


@dataclass(base_schema=OrderedSchema)
class ManSearchConfig:
    sym_threshold: int = field(default=50, metadata=dict(marshmallow_field=PercentField(
        title='Порог совпадения',
        description='Производители со степенью совпадения меньше указанного порога считаются несовпавшими',
        schema={'minimum': 0, 'maximum': 100}
    )))


@dataclass(base_schema=OrderedSchema)
class SearchConfig(ConfigElement):
    mpn: MpnSearchConfig = field(metadata=dict(title='Поиск по MPN'))
    manufacturer: ManSearchConfig = field(metadata=dict(title='Поиск по производителю'))
    params: ParamsSearchConfig = field(metadata=dict(title='Поиск по параметрам'))
    param_limit: int = field(default=10000, metadata=dict(
        title='Значений',
        description='''
Максимальное кол-во значений параметров
возвращаемых по запросу API `catalog/api/params` с фильтром `values=true`.
''',
        schema={'minimum': 1}
    ))
    min_score: int = field(default=0, metadata=dict(marshmallow_field=PercentField(
        title='Порог релевантности',
        description='Результаты с релевантностью меньше указанного порога не попадают в выдачу',
        schema={'minimum': 0, 'maximum': 100}
    )))
    limit: int = field(default=0, metadata=dict(
        title='Вариантов',
        description='Максимальное кол-во найденных вариантов для каждой поисковой строки',
        schema={'minimum': 0},
    ))
    max_score_group_limit: int = field(default=100, metadata=dict(
        title='Топ вариантов',
        description='''
Если все найденные результаты для строки оказались с максимальной релевантностью,
то лимит выдачи увеличивается до этого значения.
''',
        schema={'minimum': 1, 'maximum': 1000},
    ))
    timeout: int = field(default=10, metadata=dict(
        title='Таймаут',
        description='Таймаут поиска в elasticsearch в секундах',
        schema={'minimum': 1},
    ))
    ax_chunk_size: int = field(default=5, metadata=dict(
        title='Ограничение одновременных запросов к Аксапте',
        description='Число одновременных запросов; ограничение не глобальное - в рамках обработки одного запроса к API. Используется в quote/rezonit.',
        schema={'minimum': 1},
    ))
