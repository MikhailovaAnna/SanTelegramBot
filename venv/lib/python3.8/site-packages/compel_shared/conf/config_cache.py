from cachetools import LFUCache
from etcd3 import AioClient

from compel_shared.classes.class_ import ClassImport
from compel_shared.conf.classes_config import ClassesConfig
from compel_shared.conf.manufacturers_config import ManufacturersConfig
from compel_shared.conf.mongo_mem_cache import MongoMemCache
from compel_shared.conf.param_config import ParamConfig
from compel_shared.conf.recog_resolver import RecogResolver
from compel_shared.conf.recog_template_config import RecogTemplateConfig
from compel_shared.conf.service_config import ServiceConfigCache
from compel_shared.conf.unit_template_config import UnitTemplateConfig
from compel_shared.logger import get_logger
from compel_shared.model import DB
from compel_shared.params.param import ParamBase, ParamRecog
from compel_shared.params.param_import import ParamImport
from compel_shared.params.param_parser import TemplateParamParser, BasicParser
from compel_shared.schema import ImportManRecord, ManRecord

log = get_logger(__name__)


class ClassesImportConfig(MongoMemCache):

    def __init__(self, db, etcd_client: AioClient, recog_resolver: RecogResolver, provider: str):
        super().__init__(db, etcd_client, 'classes_import', ClassImport, provider=provider, key='code',
                         size=1000, exclude_fields={'analytic'})
        self.recog_resolver = recog_resolver

    async def _load_model(self, doc):
        model = await super()._load_model(doc)
        for k, pi in model.params.items():
            if pi.recog:
                pi.recog = await self.recog_resolver.resolve_recog(pi.recog)
        return model

    async def get_class_import(self, code: str = None, id: str = None) -> ClassImport:
        return await self.get_model(code, id)


class ManufacturersImportCache(MongoMemCache):

    def __init__(self, db, etcd_client: AioClient):
        super().__init__(db, etcd_client, 'manufacturers_import', ImportManRecord)


class ManufacturersCache(MongoMemCache):
    def __init__(self, db, etcd_client: AioClient):
        super().__init__(db, etcd_client, 'manufacturers', ManRecord, key='code', query={'code': {'$exists': True}})

    async def get_manufacturer(self, code) -> ManRecord:
        return await self.get_model(key=code)


class ParamImportCache(MongoMemCache):

    def __init__(self, db, etcd_client: AioClient, recog_resolver: RecogResolver, provider: str):
        super().__init__(db, etcd_client, 'param_import', ParamImport, provider=provider, key='name',
                         exclude_fields={'analytic'})
        self.recog_resolver = recog_resolver

    async def _load_model(self, doc):
        model = await super()._load_model(doc)
        if model.recog:
            model.recog = await self.recog_resolver.resolve_recog(model.recog)
        return model


class ParserCache:

    def __init__(self, param_config: ParamConfig, service_config: ServiceConfigCache, size=2000):
        self.param_config = param_config
        self.service_config = service_config
        self._parser_cache = LFUCache(size)

        for m in [self.param_config.add_on_change,
                  self.param_config.recog_resolver.rtc.add_on_change,
                  self.param_config.recog_resolver.utc.add_on_change,
                  self.service_config.add_on_change,
                  self.param_config.add_on_clear,
                  self.param_config.recog_resolver.rtc.add_on_clear,
                  self.param_config.recog_resolver.utc.add_on_clear,
                  self.service_config.add_on_clear]:
            m(self._clear_cache)

    async def get_parser(self, param_name: str, class_code: str = None, param: ParamBase = None):
        cache_key = (class_code, param_name)
        parser = self._parser_cache.get(cache_key)
        if not parser:
            if param:
                recog = param.recog or ParamRecog()
                if recog:
                    if recog.template_selector and recog.template_selector.templates:
                        unit_config = await self.service_config.get_section('units')
                        parser = TemplateParamParser(unit_config=unit_config, param_recog=recog)
                    else:
                        parser = BasicParser()
                    self._parser_cache[cache_key] = parser
        return parser

    def _clear_cache(self):
        self._parser_cache.clear()


class ConfigCache:
    # TODO: разобраться с ManufacturersImport, ParamImport

    def __init__(self, db: DB, etcd_client: AioClient, provider=None):
        self.db = db
        self.recog_resolver = RecogResolver(RecogTemplateConfig(db, etcd_client, provider),
                                            UnitTemplateConfig(db, etcd_client, provider))
        self.classes = ClassesConfig(db, etcd_client, self.recog_resolver)
        self.classes_import = ClassesImportConfig(db, etcd_client, self.recog_resolver, provider)  # fill_external
        self.manufacturers = ManufacturersConfig(db, etcd_client)
        self.manufacturers_import = ManufacturersImportCache(db, etcd_client)  # где используется?
        self.param = ParamConfig(db, etcd_client, self.recog_resolver)
        self.param_import = ParamImportCache(db, etcd_client, self.recog_resolver, provider)  # где используется?
        self.service_config = ServiceConfigCache(db, etcd_client, size=10)
        self.parser_cache = ParserCache(self.param, self.service_config)
        self.caches = [
            self.recog_resolver.rtc,
            self.recog_resolver.utc,
            self.classes,
            self.classes_import,
            self.manufacturers,
            self.manufacturers_import,
            self.param,
            self.param_import,
            self.service_config,
        ]

    async def clean_up_config_cache(self):
        """
        Очистка всех кэшей. Используется в etl/clean_up.
        """
        for cache in self.caches:
            await cache.load_version()
            await cache.inc_version()

    async def watch(self):
        for cache in self.caches:
            await cache.load_version()
            await cache.watch()

    async def stop(self):
        for cache in self.caches:
            await cache.stop()
