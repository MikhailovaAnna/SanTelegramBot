from asyncio import CancelledError

import asyncio
import json
from datetime import datetime, timedelta
from typing import Callable

from cachetools import LFUCache
from etcd3 import AioClient

from compel_shared.conf import load_schema
from compel_shared.conf.etcd_notifier import ETCDNotifier
from compel_shared.logger import get_logger
from compel_shared.model import DB

log = get_logger(__name__)


class MongoMemCache(ETCDNotifier):
    idle_time = timedelta(seconds=60)

    def __init__(self, db: DB,
                 etcd_client: AioClient,
                 collection: str,
                 model_class=None,
                 key=None,
                 provider=None,
                 exclude_fields=None,
                 size=100,
                 query: dict = None,
                 cool_down=10):
        super().__init__(etcd_client, collection)
        self.data_cache_id = LFUCache(size)
        self.data_cache_key = LFUCache(size)
        self.data_cache_query = LFUCache(size)
        self.model_cache_id = LFUCache(size)
        self.model_cache_key = LFUCache(size)
        self.model_cache_query = LFUCache(size)
        self.query = query or {}
        self.db = db
        self.collection_name = collection
        self.collection = db.get_collection(collection)
        self.key = key
        if self.key:
            self.query.update({self.key: {'$exists': True}})
        self.provider = provider
        if self.provider:
            self.query.update({'provider': provider})
        self.schema = None
        if model_class:
            self.schema = model_class.Schema
        self.projection = None
        if exclude_fields:
            self.projection = {k: 0 for k in exclude_fields}
        self.add_on_change(self._clear_cache)
        self.last_access = datetime.now()
        self._touch()
        self.evict_task = None
        self.cool_down = cool_down
        self.on_clear = []

    async def get_data(self, key: str = None, id: str = None, query: dict = None):
        docs = await self._get_data(key, id, query)
        return docs

    async def get_model(self, key: str = None, id: str = None, query: dict = None):
        """
        Получаем данные в виде модели: грузим в виде сырых данных (из кэша, потом из монги если нет в кэше),
        затем приводим в вид модели.
        @rtype: object single model or dict key:model
        """
        query_cache_key = None
        if key is not None:
            cache = self.model_cache_key
            k = key
        elif id:
            cache = self.model_cache_id
            k = id
        else:
            cache = self.model_cache_query
            k = self._query_to_string(query or self.query)
            query_cache_key = k

        data = cache.get(k)
        self._touch()
        if not data:
            data = await self._get_data(key, id, query)
            if data:
                data = await self._load_data_model(data, query_cache_key)
        return data

    async def watch(self):
        await super().watch()
        self.evict_task = asyncio.get_event_loop().create_task(self._eviction_task())

    async def stop(self):
        await super().stop()
        if self.evict_task:
            self.evict_task.cancel()
            try:
                await self.evict_task
            except CancelledError:
                pass
            self.evict_task = None

    def add_on_clear(self, callback: Callable):
        self.on_clear.append(callback)

    def _clear_cache(self):
        """
        При каждом обновлении версии через ETCD кэш сбрасывается.
        """
        self.data_cache_id.clear()
        self.data_cache_key.clear()
        self.data_cache_query.clear()
        self.model_cache_id.clear()
        self.model_cache_key.clear()
        self.model_cache_query.clear()
        self.dirty = False
        log.info(f'Cleared cache for {self.collection_name}', collection=self.collection_name)

    async def _get_data(self, key: str = None, id: str = None, query: dict = None):
        """
        Получаем данные в сыром виде - в том виде, в котором они лежат в монге, без преобразования в модель.
        Записи по id кэшируются всегда, по ключу - если есть ключ.
        При запросе нескольких документов (по query) кэшируется каждый документ отдельно (по id и ключу) и
        результат query целиком.
        """
        query_cache_key = None
        if key is not None:
            query = {self.key: key}
            k = key
            cache = self.data_cache_key
            if self.provider:
                query['provider'] = self.provider
        elif id:
            query = {'_id': id}
            k = id
            cache = self.data_cache_id
        else:
            query = query or self.query
            k = self._query_to_string(query)
            cache = self.data_cache_query
            query_cache_key = k

        docs = cache.get(k)
        self._touch()
        if not docs:
            log.debug(f'Loading {query} from {self.collection_name}')
            docs = await self.collection.find(query, projection=self.projection).to_list(length=None)
            if docs:
                docs = await self._write_to_data_cache(docs, query_cache_key)
        return docs

    async def _load_model(self, doc):
        return load_schema(self.schema, doc)

    @staticmethod
    def _query_to_string(query: dict):
        return json.dumps(query)

    async def _write_to_data_cache(self, docs, query_cache_key):
        query_cache = self.data_cache_query
        for doc in docs:
            self._cache_single_doc(doc)
        if query_cache_key:
            key = self.key or '_id'
            data = {doc[key]: doc for doc in docs}
            query_cache[query_cache_key] = data
        else:
            data = docs[0]
        return data

    async def _load_data_model(self, data, query_cache_key):
        # docs приходит одним документом или dict в виде {<ключ/id>: <документ>}
        if query_cache_key:
            # несколько документов
            models = {}
            for k, v in data.items():
                try:
                    model = await self._load_model(v)
                    models[k] = model
                    self._cache_single_doc(v, model)
                except Exception as e:
                    log.exception('Failed to cache doc', doc=v, collection=self.collection_name)

            self.model_cache_query[query_cache_key] = models
            return models
        else:
            # один документ
            model = await self._load_model(data)
            self._cache_single_doc(data, model)
            return model

    def _cache_single_doc(self, doc, model=None):
        id_cache = self.model_cache_id if model else self.data_cache_id
        key_cache = self.model_cache_key if model else self.data_cache_key
        cached_value = model or doc
        id_cache[doc['_id']] = cached_value
        if self.key:
            key_val = doc.get(self.key)
            if key_val:
                key_cache[key_val] = cached_value

    async def _eviction_task(self):
        while True:
            await asyncio.sleep(self.cool_down)
            try:
                if self.dirty and datetime.now() - self.last_access >= self.idle_time:
                    self._clear_cache()
                    for cb in self.on_clear:
                        try:
                            cb()
                        except Exception as e:
                            log.exception('Failed to run callback on clear')
            except Exception as e:
                log.exception('Failed cache cleanup')

    def _touch(self):
        self.last_access = datetime.now()
        self.dirty = True

    def __str__(self):
        str_name = f'{self.collection_name}'
        if self.provider:
            str_name += f' [{self.provider}]'
        return str_name
