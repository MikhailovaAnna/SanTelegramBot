from asyncio import CancelledError

import asyncio
import logging
from os.path import join
from typing import Callable

from etcd3 import AioClient

from compel_shared.config import ETCD_HOST, ETCD_PORT, ETCD_CERT_DIR

log = logging.getLogger(__name__)


class ETCDNotifier:
    etcd_prefix = 'service'

    def __init__(self, etcd_client: AioClient, name):
        self.client = etcd_client
        self.name = name
        self.watcher = None
        self.version = 0
        self.etcd_key = f'{self.etcd_prefix}/{self.name}'.encode()
        self.running = False
        self.on_changed = []

    async def __aenter__(self):
        await self.load_version()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        pass

    async def on_change(self, version):
        if self.version < version:
            await self.load_version()
            self._run_onchange()

    def add_on_change(self, callback: Callable):
        self.on_changed.append(callback)

    async def load_version(self):
        resp = await self.client.range(self.etcd_key)
        if resp.kvs:
            self.version = int(resp.kvs[0].value.decode())
        log.info(f'Loaded {self.name} v{self.version}')

    async def inc_version(self):
        self.version += 1
        await self._set_version(self.version)

    async def _set_version(self, version):
        """
        Set config to new version.
        Call this each time new version is saved.
        @param version:
        """
        await self.client.put(self.etcd_key, str(version).encode())

    async def watch(self):
        if not self.client:
            raise Exception(f'Client was not set')
        self.running = True
        self.watcher = asyncio.get_event_loop().create_task(self._watch_loop())

    async def stop(self):
        if self.running:
            self.running = False
            self.watcher.cancel()
            try:
                await self.watcher
            except CancelledError:
                pass
            self.watcher = None

    def _run_onchange(self):
        for cb in self.on_changed:
            try:
                cb()
            except Exception as e:
                log.exception(f'Error with callback - {e}')

    async def _watch_loop(self):
        while self.running:
            try:
                async with self.client.watch_create(self.etcd_prefix, range_end=get_range_end(self.etcd_prefix)) as r:
                    async for msg in r:
                        log.info(msg)
                        if msg.events:
                            for event in msg.events:
                                try:
                                    name = event.kv.key.decode()[len(self.etcd_prefix) + 1:]
                                    if name == self.name:
                                        version = int(event.kv.value.decode())
                                        log.info(f"{self.name} changed to v{version}")
                                        await self.on_change(int(event.kv.value.decode()))
                                except Exception as e:
                                    log.exception(f'Failed to process event : {event}')
            except Exception as e:
                if self.running:
                    log.exception(f'Watch interrupted for {self.name}')
                    await  asyncio.sleep(1)


def create_etcd_client():
    kwargs = {}
    if ETCD_CERT_DIR:
        kwargs = {
            'cert': (join(ETCD_CERT_DIR, 'cert.pem'), join(ETCD_CERT_DIR, 'key.pem')),
            'verify': join(ETCD_CERT_DIR, 'ca.pem')
        }
    try:
        return AioClient(ETCD_HOST, ETCD_PORT, **kwargs)
    except Exception as e:
        log.exception('ETCD init failed')
        raise Exception(f'ETCD connect failed @ {ETCD_HOST}:{ETCD_PORT} {kwargs}')


def get_range_end(prefix):
    return prefix[:-1] + chr(ord(prefix[-1]) + 1)
