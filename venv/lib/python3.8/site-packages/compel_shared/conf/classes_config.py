import typing

from etcd3 import AioClient
from funcy import get_in

from compel_shared import config
from compel_shared.classes.class_ import Class
from compel_shared.conf.mongo_mem_cache import MongoMemCache
from compel_shared.logger import get_logger
from compel_shared.model import DB

log = get_logger(__name__)


class ClassesConfig(MongoMemCache):

    def __init__(self, db: DB, etcd_client: AioClient, recog_resolver):
        super().__init__(db, etcd_client, 'classes', Class, key='code', exclude_fields={'analytic'},
                         query={'recognized': True, 'code': {'$exists': True}})
        self.recog_resolver = recog_resolver
        self._tech_types = dict()
        self._root_tech_type = None
        self._all_param_codes = None
        self.recog_resolver.rtc.add_on_change(self._clear_cache)
        self.recog_resolver.utc.add_on_change(self._clear_cache)

    async def get_classes(self) -> typing.Dict[str, Class]:
        return await self.get_model()

    async def get_class(self, code) -> Class:
        return await self.get_model(key=code)

    async def get_tech(self, id) -> typing.Dict:
        """
        Returns class tech map
        @param id:  class ID
        @return:      class tech map dict keys: [m10, ems]
        """

        async def fill_tech_map():
            clazz = await self.get_data(id=id)
            tech_map = {i: get_in(clazz, ["tech", i]) for i in config.TECHS}
            while None in tech_map.values() and clazz and clazz.get("parent_id"):
                clazz = await self.get_data(id=clazz.get("parent_id"))
                for i in config.TECHS:
                    tech = get_in(clazz, ["tech", i])
                    if tech and not tech_map.get(i):
                        tech_map[i] = tech
            return tech_map

        tech_map: typing.Dict = self._tech_types.get(id)
        if tech_map is None:
            tech_map = await fill_tech_map()
            self._tech_types[id] = tech_map

        return tech_map

    async def get_root_tech(self) -> typing.Dict:
        """
        Retunrs root class (axapta_id = 04) tech map
        :return:
        """
        if self._root_tech_type is None:
            self._root_tech_type = (await self.db.classes.find_one({'axapta_id': '04'})).get('tech') or dict()
        return self._root_tech_type

    async def get_all_param_codes(self) -> typing.Set[str]:
        """All existing param codes strictly from DB"""
        result = self._all_param_codes
        if result is None:
            result = set()
            async for class_dict in self.collection.find({}):
                params = class_dict.get('params')
                if params:
                    for param_code in params:
                        result.add(param_code)
            self._all_param_codes = result
            log.info(f'Reloaded all_param_codes from DB', len=len(result))
        return result

    async def _load_model(self, doc):
        doc = await super()._load_model(doc)  # type: Class
        for param in doc.params.values():
            if param.recog:
                param.recog = await self.recog_resolver.resolve_recog(param.recog)
        return doc

    def _clear_cache(self):
        super()._clear_cache()
        self._tech_types = dict()
        self._root_tech_type = None
        self._all_param_codes = None
