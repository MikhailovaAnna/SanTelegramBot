import decimal
import typing
from dataclasses import field
from datetime import datetime
from enum import Enum

from marshmallow import Schema, pre_dump, pre_load, EXCLUDE
from marshmallow.fields import *
from marshmallow_dataclass import dataclass, NewType

from compel_shared.config import LANGS


def pick_field_data(schema_class, field_name, **kwargs):
    fld = schema_class().fields[field_name]
    mdata = fld.metadata.copy()
    mdata.update(kwargs)
    return mdata


def pick_field(schema_class, field_name, **kwargs):
    """
    Use this to steal field declaration from another schema class
    @param schema_class:
    @param field_name:
    @param kwargs: extra args to override or attach to new field
    @return:
    """
    fld = schema_class().fields[field_name]
    mdata = fld.metadata.copy()
    mdata.update(kwargs)
    return fld.__class__(**mdata)


class DictField(Field):

    def __init__(self, cls_or_instance, **kwargs):
        super().__init__(**kwargs)
        if isinstance(cls_or_instance, type):
            self.container = cls_or_instance()
        else:
            self.container = cls_or_instance

    def get_value(self, attr, obj, accessor=None, default=None):
        value = super().get_value(attr, obj, accessor=accessor)
        if self.container.attribute:
            return {k: self.container.get_value(self.container.attribute, value[k]) for k in value}
        return value

    def _serialize(self, value, attr, obj, **kwargs):
        if value is None:
            return None
        return {k: self.container._serialize(value[k], attr, obj) for k in value}

    def _deserialize(self, value, attr, data, **kwargs):
        if not isinstance(value, dict):
            self.fail(f'{value} is not dict')
        return {k: self.container.deserialize(value[k]) for k in value if value[k]}


class DecimalField(Field):

    def _serialize(self, value, attr, obj, **kwargs):
        if value is None:
            return None
        return str(value)

    def _deserialize(self, value, attr, data, **kwargs):
        if value is None:
            return None
        return decimal.Decimal(value)


class DateTimeField(DateTime):

    def _deserialize(self, value, attr, data, **kwargs):
        if isinstance(value, datetime):
            return value
        else:
            return super()._deserialize(value, attr, data, **kwargs)


class JoinField(List):
    def __init__(self, target_schema, target_field, target_collection, **kwargs):
        super().__init__(Str, **kwargs)
        self.target_schema = target_schema
        self.target_field = target_field
        self.target_collection = target_collection


class PagingRequestSchema(Schema):
    offset = Int(title='Сдвиг', description='Количество пропускаемых документов от начала', example=0, default=0)
    limit = Int(title='Лимит', description='Макс. количество документов в одном запросе', example=20, default=100)

    def get_value(self, data: typing.Dict, field_name):
        default = self.fields[field_name].default
        value = data.get(field_name, default)
        try:
            value = int(value)
        except Exception as e:
            value = default
        return value

    def get_limit(self, data):
        return max(1, self.get_value(data, 'limit'))

    def get_offset(self, data):
        return max(1, self.get_value(data, 'offset'))


paging_request_schema = PagingRequestSchema()


class PagingResponseSchema(PagingRequestSchema):
    total = Int(title='Всего документов', description='Общее кол-во найденных документов', example=2000, default=0)


class OrderedSchema(Schema):
    class Meta:
        ordered = True
        unknown = EXCLUDE


class MongoIDSchema(OrderedSchema):
    id = Str(
        required=True,
        title='Идентификатор',
        description='Идентификатор документа в хранилище',
        example='YspbdJ98N5',
        is_hidden=True
    )

    @pre_load
    def read_id(self, data, **kwargs):
        if self._is_mongo:
            self.demongolize(data)
        return data

    @pre_dump
    def write_id(self, data, **kwargs):
        if self._is_mongo:
            self.mongolize(data)
        return data

    @property
    def _is_mongo(self):
        return self.context.get('type') == 'mongo'

    @staticmethod
    def mongolize(data):
        if 'id' in data:
            data['_id'] = data.pop('id')

    @staticmethod
    def demongolize(data):
        if '_id' in data:
            data['id'] = data.pop('_id')


class CRUDSchema(MongoIDSchema):
    created = DateTimeField(title='Время создания',
                            description='Время создания документа в хранилище',
                            is_hidden=True)
    updated = DateTimeField(title='Время обновления',
                            description='Время обновления документа в хранилище',
                            is_hidden=True)


class ClientContextSchema(Schema):
    client_id = Str(title='ID клиента', description='ID клиента', example='БАЗАЭЛ63RC')
    client_group_id = Str(title='ID группы клиента', description='ID группы клиента', example='5360')
    customer_id = Str(title='ID KЗ', description='ID конечного заказчика', example='БАЗАЭЛ63RC')
    customer_group_id = Str(title='ID группы KЗ', description='ID группы конечного заказчика', example='5360')


@dataclass
class ManRecord:
    code: str
    names: typing.List[str]
    blocked: typing.Optional[bool]
    ax_producers_manufacturer: typing.Optional[str]


@dataclass
class ImportManRecord:
    code: str
    name: str
    provider: str


multilang_schema = {
    'type': 'object',
    'properties': {
        lang: {'title': lang, 'type': 'string'}
        for lang in LANGS
    }
}


class MultilangField(DictField):
    def __init__(self, container=None, *args, **kwargs):
        super().__init__(
            container or Str(),
            *args,
            **{
                'schema': multilang_schema,
                **kwargs,
            }
        )


class PercentField(Int):
    def __init__(self, container=None, *args, **kwargs):
        super().__init__(*args, min_value=0, max_value=100, **kwargs)


class WeightField(PercentField):
    def __init__(self, container=None, *args, **kwargs):
        super().__init__(*args, title='Вес, %',
                         description='Вес поля (0-100) используется при расчете релевантности найденных результатов',
                         **kwargs)


class FuzzinessField(Str):
    def __init__(self, *args, **kwargs):
        super().__init__(
            *args,
            title='Макс. ред расстояние - 0, 1, 2 или AUTO',
            description='Макс. ред расстояние - 0, 1, 2 или AUTO',
            enum_values=[0, 1, 2, 'AUTO'],
            **kwargs,
        )


Multilang = NewType('Multilang', typing.Dict[str, str], schema=multilang_schema)

Weight = NewType('Weight', int,
                 min_value=0, max_value=100,
                 title='Вес',
                 description='Вес используется для расчета релевантности найденных результатов')

Fuziness = NewType('Fuziness', str,
                   title='Нечеткость',
                   description='Максимальное редакционное расстояние для нечеткого поиска',
                   enum_values=['0', '1', '2', 'AUTO'])

Samples = NewType('Samples', typing.List[typing.Any],
                  title='Примеры значений',
                  readonly=True)

DelimiterField = Str(
    description='''
Регулярное выражение (RegExp), по которому поисковая строка может быть разделена на части.
''',
    title='Разделитель строк',
    default='',
    example='\n|\t'
)


class ApplyTime(Enum):
    IMMEDIATE = 'immediate'
    BACKGROUND = 'background'
    MANUAL = 'manual'


class RenamingState(str, Enum):
    CREATED = 'CREATED'
    IN_PROGRESS = 'IN_PROGRESS'
    COMPLETED = 'COMPLETED'
    FAILED = 'FAILED'


@dataclass(base_schema=CRUDSchema)
class Renaming:
    collection: str = field(
        metadata=dict(title='Имя коллекции',
                      description='Имя коллекции в которой происходит переименование',
                      required=True))
    key: str = field(
        metadata=dict(title='Имя поля для переименования',
                      description='Имя поля в коллекции по которой будет происходить переименование',
                      required=True))
    value_old: str = field(
        metadata=dict(title='Переименовать что',
                      description='Переименовать что',
                      required=True))
    value_new: str = field(
        metadata=dict(title='Переименовывать во что',
                      description='Переименовывать во что',
                      required=True))
    state: RenamingState = field(
        metadata=dict(title='Статус',
                      description='Статус переименования',
                      required=True))


class MarkType(Enum):
    MANUAL = 'MANUAL'
    AUTO = 'AUTO'
    CLIENT = 'CLIENT'
